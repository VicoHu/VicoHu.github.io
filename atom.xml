<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VicoHu-个人博客</title>
  
  <subtitle>用程序员的眼光，戏剧地看待世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.vicohu.com/"/>
  <updated>2020-11-23T06:45:42.565Z</updated>
  <id>https://www.vicohu.com/</id>
  
  <author>
    <name>VicoHu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java多线程编程</title>
    <link href="https://www.vicohu.com/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.vicohu.com/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2020-10-12T06:25:35.000Z</published>
    <updated>2020-11-23T06:45:42.565Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、进程和线程"><a href="#一、进程和线程" class="headerlink" title="一、进程和线程"></a>一、进程和线程</h3><h4 id="进程和线程分别是什么？"><a href="#进程和线程分别是什么？" class="headerlink" title="进程和线程分别是什么？"></a>进程和线程分别是什么？</h4><ul><li><p><strong>进程</strong>（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p></li><li><p><strong>线程</strong>，有时被称为<strong>轻量级进程</strong>(Lightweight Process，LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。</p></li></ul><h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><ul><li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li><li>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多，线程的上下文切换的性能消耗要小于进程。</li><li>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。</li><li>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</li></ul><h4 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h4><p>如下图所示，一个程序可以由多个进程组成，每一个进程又可以有一个或者多个线程。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gky49rpscaj30eg0670sz.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="二、同步与异步"><a href="#二、同步与异步" class="headerlink" title="二、同步与异步"></a>二、同步与异步</h3><p>对于一次方法的调用来说，<strong>同步方法调用一旦开始，就必须等待该方法的调用返回，后续的方法才可以继续执行</strong>。</p><p><strong>异步的话，方法调用一旦开始，就可以立即返回，调用者可以执行后续的方法</strong>，这里的异步方法通常会在另一个线程里真实的执行，而不会妨碍当前线程的执行。</p><h3 id="三、并行与并发"><a href="#三、并行与并发" class="headerlink" title="三、并行与并发"></a>三、并行与并发</h3><p>在异步任务出现后，<strong>并行</strong>与<strong>并发</strong>这个词汇越来越多的出现在我们的视野中。</p><ul><li><p>共同点：</p><p>都可以表示在同一时间范围内有两个或多个任务同时在执行</p></li><li><p>不同点</p><p>任务调度的时候还是有区别。当多个任务在执行的时候，并发是没有时间上的重叠的，多个任务是交替执行的，由于切换的非常快，对于外界调用者来说相当于同一时刻多个任务一起执行了；而并行可以看到时间上是由重叠的，也就是说并行才是真正意义上的同一时刻可以有多个任务同时执行。</p></li></ul><p><strong>并发任务执行过程</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gky4p88mmtj30ex06a3yi.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>并行任务执行过程</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gky4pon891j30f0065jrd.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="四、Java实现多线程的方式"><a href="#四、Java实现多线程的方式" class="headerlink" title="四、Java实现多线程的方式"></a>四、Java实现多线程的方式</h3><ol><li><p>实现Runnable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable myRunnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myRunnable, <span class="string">"t1"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>继承Thread，重写run方法</p><h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><ul><li><p>启动线程的是start方法而不是run方法，如果用run方法，那么他就是一个普通的方法执行了。</p></li><li><p>Thread类本身实现了Runnable接口，并且持有run方法，但Thread类的run方法主体是空的，Thread类的run方法通常是由子类的run方法重写。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start(); <span class="comment">//线程启动的正确方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 Callable 和 Future 创建线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Done!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">    Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String result = future.get(); </span><br><span class="line">        <span class="comment">//get是一个阻塞方法，虽然你换了个线程，但是你取数据的时候还是会卡住</span></span><br><span class="line">        System.out.println(<span class="string">"result: "</span> + result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>feature.get() 是一个阻塞方法，那么有没有办法不卡住线程呢？ 答案是有的，那就是循环去查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = executor.submit(callable);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!future.isDone)&#123;</span><br><span class="line">    <span class="comment">//检查是否已经完成，如果否，那么可以让主线程去做其他操作，不会被阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">    String result = future.get(); </span><br><span class="line">    <span class="comment">//get是一个阻塞方法，虽然你换了个线程，但是你取数据的时候还是会卡住</span></span><br><span class="line">    System.out.println(<span class="string">"result: "</span> + result);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Executors</p><p>JDK 1.5 后引入的 Executor 框架的最大优点是把任务的提交和执行解耦。通过 Executors 的工具类可以创建以下类型的线程池：</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gky5xlc4yoj31ga0u0adq.jpg" alt=""></p><p>下面介绍常用的两种线程池。</p><ul><li><p><strong>FixThreadPool：固定大小线程池</strong></p><p>创建固定大小的线程池。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。适用于集中处理多个任务。</p><p>如果现在我需要优先处理一下图片，但是处理完就释放掉这些线程，那么代码可以这么写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService imageProcessor = Executor.newFixedThreadPool(); </span><br><span class="line"><span class="comment">//我需要你马上给我很多个线程，然后一旦用完我就不要了</span></span><br><span class="line"></span><br><span class="line">List&lt;Image&gt; images; <span class="comment">//图片集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Image image : images)&#123;</span><br><span class="line">    <span class="comment">//处理图片</span></span><br><span class="line">    improcessor.excutor(iamgeRunnable,image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等图片处理完成后终止线程</span></span><br><span class="line">imageProcessor.shutdown();</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p><strong>cacheThreadPool：缓存线程池</strong></p><p>当提交任务速度高于线程池中任务处理速度时，缓存线程池会不断地创建线程，适用于提交短期的异步小程序，以及负载较轻的服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">executor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Thread with Runnable started!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Executor executor = Executors.newCachedThreadPool();</span><br><span class="line">    executor.execute(runnable);</span><br><span class="line">    executor.execute(runnable);</span><br><span class="line">    executor.execute(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Executor 接口里面有两个重要的方法，一个是 shutdown，一个是 shutdownNow。</p><p>它们两个的区别是：shutdown 不再允许扔新的 runnable 进来。shutdownNow 不只是新的不允许，就算是正在执行的任务也不允许再继续执行。</p></li></ul><h3 id="五、线程安全"><a href="#五、线程安全" class="headerlink" title="五、线程安全"></a>五、线程安全</h3><p><strong>线程安全概念</strong>：当多个线程访问某一个类（对象或方法）时，这个类始终能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。</p><h4 id="JVM内存模型特点："><a href="#JVM内存模型特点：" class="headerlink" title="JVM内存模型特点："></a>JVM内存模型特点：</h4><ul><li>Java 所有变量都存储在主内存中。</li><li>每个线程都有自己独立的工作内存，里面保存该线程使用到的变量副本。</li><li>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接在主内存读写。</li><li>不同线程之间无法访问其他线程内存中的变量，线程间变量值的传递需要通过主内存来完成。线程 1 对共享变量的修改，要想被线程 2 及时看到，必须经过如下 2 个过程：<ol><li>把工作内存 1 中更新过的共享变量刷新到主内存中。</li><li>将主内存中最新的共享变量的值更新到工作内存 2 中。</li></ol></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gky7mlxtq9j30vi0igdgi.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="Synchronized的使用"><a href="#Synchronized的使用" class="headerlink" title="Synchronized的使用"></a>Synchronized的使用</h4><p>synchronized 可以<strong>保证在同一时刻只有一个线程执行被 synchronized 修饰的方法/代码</strong>，即保证操作的原子性和可见性。</p><p>具体的使用可见博客另一片博文《Java中Synchonized的答疑》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、进程和线程&quot;&gt;&lt;a href=&quot;#一、进程和线程&quot; class=&quot;headerlink&quot; title=&quot;一、进程和线程&quot;&gt;&lt;/a&gt;一、进程和线程&lt;/h3&gt;&lt;h4 id=&quot;进程和线程分别是什么？&quot;&gt;&lt;a href=&quot;#进程和线程分别是什么？&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Java" scheme="https://www.vicohu.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.vicohu.com/tags/Java/"/>
    
      <category term="多线程" scheme="https://www.vicohu.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java中Synchronized的答疑</title>
    <link href="https://www.vicohu.com/Java%E4%B8%ADSynchronized%E7%9A%84%E7%AD%94%E7%96%91/"/>
    <id>https://www.vicohu.com/Java%E4%B8%ADSynchronized%E7%9A%84%E7%AD%94%E7%96%91/</id>
    <published>2020-09-27T08:20:15.000Z</published>
    <updated>2020-11-23T06:42:04.708Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么场景下需要使用Synchronized？"><a href="#什么场景下需要使用Synchronized？" class="headerlink" title="什么场景下需要使用Synchronized？"></a>什么场景下需要使用Synchronized？</h4><p>在多线程编程中，当多个线程在使用同一个共享资源的时候时候，并可能对共享资源进行修改的时候，需要使用到Synchronized。</p><p>如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gky11u1c9kj30ez0a6mxx.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="为什么要使用Synchronized？"><a href="#为什么要使用Synchronized？" class="headerlink" title="为什么要使用Synchronized？"></a>为什么要使用Synchronized？</h4><p>多个线程对同一个资源进行读取和修改，可能会导致<strong>脏读</strong>，而导致修改结果与预期不一致，因为该线程读取（复制）到的值，并非共享资源当前真实的值，因为其他线程此刻可能已经对该共享资源进行了修改。</p><p>因此，需要使用<strong>锁</strong>来对共享资源进行锁定，确保所有的线程在当前线程对数据修改完成前，其他线程都处于等待修改状态，而避免<strong>脏读</strong>导致的与预期不一致的情况。</p><h4 id="synchronized-的作用范围？"><a href="#synchronized-的作用范围？" class="headerlink" title="synchronized 的作用范围？"></a>synchronized 的<strong>作用范围</strong>？</h4><ol><li>在静态方法上加锁。</li><li>在非静态方法上加锁。</li><li>在代码块上加锁。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedSample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> money = <span class="number">0</span>;</span><br><span class="line">           <span class="comment">//非静态方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">noStaticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">           money++;</span><br><span class="line">       &#125;</span><br><span class="line">           <span class="comment">//静态方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">           money++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">codeBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="comment">//代码块</span></span><br><span class="line">           <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">               money++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Synchronized-三种作用范围的加锁方式的区别"><a href="#Synchronized-三种作用范围的加锁方式的区别" class="headerlink" title="Synchronized 三种作用范围的加锁方式的区别?"></a>Synchronized 三种作用范围的加锁方式的区别?</h4><p>首先，锁是加在<strong>对象</strong>上的，我们是在<strong>对象</strong>上加锁。这也就是为什么wait方法和notify方法需要先锁定对象，才能执行。因为必须要先有锁，才能释放锁。</p><table><thead><tr><th align="center">作用范围</th><th align="center">锁住的对象</th></tr></thead><tbody><tr><td align="center">静态方法</td><td align="center">当前类实例对象（this）</td></tr><tr><td align="center">非静态方法</td><td align="center">当前类对象</td></tr><tr><td align="center">代码块</td><td align="center">指定的对象（ Synchronized(指定对象) ）</td></tr></tbody></table><h4 id="JVM-是怎么通过-synchronized-在对象上实现加锁，保证多线程访问竞态资源安全的？"><a href="#JVM-是怎么通过-synchronized-在对象上实现加锁，保证多线程访问竞态资源安全的？" class="headerlink" title="JVM 是怎么通过 synchronized 在对象上实现加锁，保证多线程访问竞态资源安全的？"></a>JVM 是怎么通过 synchronized 在对象上实现加锁，保证多线程访问竞态资源安全的？</h4><p>在 JDK6 以前，synchronized 那时还属于<strong>重量级锁</strong>。每次加锁都依赖操作系统 Mutex Lock (互斥锁)实现，涉及到操作系统让线程从<strong>用户态</strong>切换到<strong>内核态</strong>，切换成本很高。</p><p>到了 JDK6，研究人员引入了<strong>偏向锁</strong>和<strong>轻量级锁</strong>。</p><h4 id="synchronized-是公平锁还是非公平锁？"><a href="#synchronized-是公平锁还是非公平锁？" class="headerlink" title="synchronized 是公平锁还是非公平锁？"></a>synchronized 是公平锁还是非公平锁？</h4><p>非公平锁。主要有以下二点原因：</p><ul><li>Synchronized 在线程竞争锁时，首先做的不是直接进 ContentionList 队列排队，而是尝试自旋获取锁（可能 ContentionList 有别的线程在等锁），如果获取不到才进入 ContentionList，这明显对于已经进入队列的线程是不公平的。</li><li>另一个不公平的是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么场景下需要使用Synchronized？&quot;&gt;&lt;a href=&quot;#什么场景下需要使用Synchronized？&quot; class=&quot;headerlink&quot; title=&quot;什么场景下需要使用Synchronized？&quot;&gt;&lt;/a&gt;什么场景下需要使用Synchronize
      
    
    </summary>
    
    
      <category term="Java" scheme="https://www.vicohu.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.vicohu.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>C# 索引器</title>
    <link href="https://www.vicohu.com/CSharp%20%E7%B4%A2%E5%BC%95%E5%99%A8%20/"/>
    <id>https://www.vicohu.com/CSharp%20%E7%B4%A2%E5%BC%95%E5%99%A8%20/</id>
    <published>2020-08-23T09:20:45.000Z</published>
    <updated>2020-09-09T12:11:11.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引器的定义"><a href="#索引器的定义" class="headerlink" title="索引器的定义"></a>索引器的定义</h3><blockquote><p>索引器允许类或结构的实例就像数组一样进行索引。 无需显式指定类型或实例成员，即可设置或检索索引值。 索引器类似于<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/properties" target="_blank" rel="noopener">属性</a>，不同之处在于它们的访问器需要使用参数。</p></blockquote><h3 id="索引器的使用场景"><a href="#索引器的使用场景" class="headerlink" title="索引器的使用场景"></a>索引器的使用场景</h3><blockquote><p>不知道各位是否有遇到过这样一种情况，我们基于一个类或继承于同一个父类或接口的类，实例化多个对象，却无法进行统一的管理和定义。即使是利用 List<T> 进行管理，依旧有很多不方便和局限的地方。</p></blockquote><p>索引器的出现，就是为了解决这个问题，它允许类或结构的实例就像数组一样进行索引。</p><h3 id="索引器的-C-实现简单例子"><a href="#索引器的-C-实现简单例子" class="headerlink" title="索引器的 C# 实现简单例子"></a>索引器的 C# 实现简单例子</h3><h4 id="定义索引器"><a href="#定义索引器" class="headerlink" title="定义索引器"></a>定义索引器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定一个索引器SimpleCollection</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCollection</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">// 定一个数组，转载这些传入的数据</span></span><br><span class="line">    <span class="keyword">private</span> T[] arr = <span class="keyword">new</span> T[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个属性，用于获取数组的长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Length =&gt; arr.Length;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义一个索引器，允许使用[]对数据进行索引</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">this</span>[<span class="keyword">int</span> i]</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; arr[i];</span><br><span class="line">        set =&gt; arr[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义一个需要使用索引器的类"><a href="#定义一个需要使用索引器的类" class="headerlink" title="定义一个需要使用索引器的类"></a>定义一个需要使用索引器的类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个Car类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> string name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(string name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="索引器的使用"><a href="#索引器的使用" class="headerlink" title="索引器的使用"></a>索引器的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      SimpleCollection&lt;Car&gt; simple = <span class="keyword">new</span> SimpleCollection&lt;Car&gt;();</span><br><span class="line">      simple[<span class="number">0</span>] = <span class="keyword">new</span> Car(<span class="string">"Car"</span>);</span><br><span class="line">      simple[<span class="number">1</span>] = <span class="keyword">new</span> Car(<span class="string">"Car1"</span>);</span><br><span class="line">      simple[<span class="number">2</span>] = <span class="keyword">new</span> Car(<span class="string">"Car2"</span>);</span><br><span class="line">      simple[<span class="number">3</span>] = <span class="keyword">new</span> Car(<span class="string">"Car3"</span>);</span><br><span class="line">      simple[<span class="number">4</span>] = <span class="keyword">new</span> Car(<span class="string">"Car4"</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; simple.Length; i++)</span><br><span class="line">      &#123;</span><br><span class="line">           Console.WriteLine(simple[i].name);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出以下内容：</span></span><br><span class="line"><span class="comment">Car</span></span><br><span class="line"><span class="comment">Car1</span></span><br><span class="line"><span class="comment">Car2</span></span><br><span class="line"><span class="comment">Car3</span></span><br><span class="line"><span class="comment">Car4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="索引器实际使用"><a href="#索引器实际使用" class="headerlink" title="索引器实际使用"></a>索引器实际使用</h3><blockquote><p>在更多的时候，我们不会像上面的实例一样去写索引器。更多的时候，是索引器的定义内，加入一些对数据进行处理的方法。</p></blockquote><p>例如上面的例子，我们希望可以讲输出car属性的方法，内置在索引器内。</p><h4 id="定义新的索引器"><a href="#定义新的索引器" class="headerlink" title="定义新的索引器"></a>定义新的索引器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定一个索引器SimpleCollection</span></span><br><span class="line">public class SimpleCollection&lt;T&gt; where T:Car</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 定一个数组，转载这些传入的数据</span></span><br><span class="line">    <span class="keyword">private</span> T[] arr = <span class="keyword">new</span> T[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个属性，用于获取数组的长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Length =&gt; arr.Length;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 定义一个索引器，允许使用[]对数据进行索引</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">this</span>[<span class="keyword">int</span> i]</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; arr[i];</span><br><span class="line">        set =&gt; arr[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">/// 输出所有方法的name属性的值</span></span><br><span class="line">    <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayAllName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(arr[i].name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段新的代码，除了新增了一个 <strong>SayAllName</strong> 的方法之外，还有一个细节，在第一行，多了个 <strong><u>where T : Car</u></strong>，这个是为了约束这个索引器的泛型只能是继承于 <strong>Car</strong> 的类。这样，就相当于，告诉当前索引器，索引器索引的实例继承于 <strong>Car 类</strong>，所以<strong>可以在使用 Car 所允许继承的<u>方法</u>和<u>属性</u></strong>。</p><h4 id="索引器的使用-1"><a href="#索引器的使用-1" class="headerlink" title="索引器的使用"></a>索引器的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      SimpleCollection&lt;Car&gt; simple = <span class="keyword">new</span> SimpleCollection&lt;Car&gt;();</span><br><span class="line">      simple[<span class="number">0</span>] = <span class="keyword">new</span> Car(<span class="string">"Car"</span>);</span><br><span class="line">      simple[<span class="number">1</span>] = <span class="keyword">new</span> Car(<span class="string">"Car1"</span>);</span><br><span class="line">      simple[<span class="number">2</span>] = <span class="keyword">new</span> Car(<span class="string">"Car2"</span>);</span><br><span class="line">      simple[<span class="number">3</span>] = <span class="keyword">new</span> Car(<span class="string">"Car3"</span>);</span><br><span class="line">      simple[<span class="number">4</span>] = <span class="keyword">new</span> Car(<span class="string">"Car4"</span>);</span><br><span class="line">      simple.SayAllName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出以下内容：</span></span><br><span class="line"><span class="comment">Car</span></span><br><span class="line"><span class="comment">Car1</span></span><br><span class="line"><span class="comment">Car2</span></span><br><span class="line"><span class="comment">Car3</span></span><br><span class="line"><span class="comment">Car4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由此可见，依旧可以完成我们预期的任务。但这样，可以让主函数的逻辑更加清晰明了，也方便了继承于 <strong>Car</strong> 或 <strong>Car类</strong> 的所有实例，可以使用他们共用的一种方法 <strong>SayAllName</strong>。这能大大加快了我们的编码效率。</p><p>所以，建议在日常的开发中，对需要一起操作的多个同父的类，多使用索引器，加快自己的开发效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;索引器的定义&quot;&gt;&lt;a href=&quot;#索引器的定义&quot; class=&quot;headerlink&quot; title=&quot;索引器的定义&quot;&gt;&lt;/a&gt;索引器的定义&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;索引器允许类或结构的实例就像数组一样进行索引。 无需显式指定类型或实例成员，即可设
      
    
    </summary>
    
    
      <category term="C#" scheme="https://www.vicohu.com/categories/C/"/>
    
    
      <category term="C#" scheme="https://www.vicohu.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式——Observe模式（观察者模式）</title>
    <link href="https://www.vicohu.com/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Observe%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89/"/>
    <id>https://www.vicohu.com/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Observe%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89/</id>
    <published>2020-07-17T12:15:21.000Z</published>
    <updated>2020-09-05T11:25:14.055Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通常一个<strong>优秀的项目</strong>，会使用到很多的<strong>设计模式</strong>，这些设计模式在我们的解决方案中，会起到<strong>十分重要</strong>的作用，它的存在，能使项目的<strong>结构</strong>更加<strong>简洁</strong>、<strong>清晰</strong>、<strong>易于理解</strong>。<br>所以了解常用的设计模式，会让我们在日常开发更加得心应手，也会让团队沟通变得更加顺畅。<br>在《<strong>设计模式：可复用面向对象软件基础</strong>》一书中强调：<strong><u>当我们评估一个面向对象系统的质量时，所使用的方法之一就是判断系统的设计者是否强调了对象之间的公共系统关系</u></strong>。</p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>那么在当前这个博文中，我介绍的就是 <strong>JavaScript 语言</strong>的 <strong>Observer设计模式</strong>。<br>初次接触 <strong>Observer设计模式</strong>，是在 <strong>Vue</strong> 的<strong>双向数据绑定</strong>中。其原理就是使用了 <strong>Observer-观察者</strong> 对数据进行<strong>劫持</strong>，然后让数据的读写全部处于监管之中。然后再使用<strong>发布-订阅模式</strong>的<strong>Publish-发布者</strong>通知到<strong>Subscribe-订阅者</strong>，对<strong>数据</strong>进行<strong>进行相应操作</strong>，比如双向数据绑定中的<strong>视图更新</strong>。</p><p>所以，<strong>Vue</strong>的一个数据的写入，要经过这样一个<strong>流程</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200718193226270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTczNjgxOA==,size_16,color_FFFFFF,t_70" alt="流程图" title="">                </div>                <div class="image-caption">流程图</div>            </figure><p>所以，实际上，<strong>Vue</strong> 数据的<strong>双向绑定</strong>，使用到了2个设计模式：<strong>Obsever模式</strong>和<strong>Publish–Subscribe模式</strong>。(有一些人认为，观察者模式和订阅观察模式是一个模式，其实不然，他们还是有一些区别的)</p><h3 id="Observer模式（观察者模式）"><a href="#Observer模式（观察者模式）" class="headerlink" title="Observer模式（观察者模式）"></a>Observer模式（观察者模式）</h3><blockquote><p>就像发明一个新的东西一样，<strong>新的发明</strong>，必定会有其在<strong>现实世界</strong>的<strong>启发</strong>。<br>就好比<strong>雷达</strong>的发明，源自于<strong>蝙蝠</strong>的<strong>超声波回声定位</strong>。<strong>火箭</strong>的发明，源自于<strong>水母、墨鱼</strong>的<strong>反冲运动</strong>。</p></blockquote><blockquote><p>无独有偶，<strong>观察者模式</strong>也一样。在现实社会中，经常会出现<strong>观察者</strong>这个身份。比如<strong>书店</strong>，他们就是观察者。既然，有了观察者，那一定会有<strong>被观察者</strong>，他们就像是<strong>出版社</strong>。<br><strong>书店<u>“监视”</u>各个出版社的新书，若出版社<u>出现了新书</u>（观察者在监视的行为），则书店<u>获得了</u>出版社的信息（被观察者的对象信息）和出版社的发布新书（被观察者的变化），然后书店将其发布的新书拿到，并<u>告诉</u>关注该类书的读者（观察者做出相应操作）</strong></p></blockquote><blockquote><p><strong>Observer模式</strong>的大致流程如上。话不多说，我们着手开始用 <strong>JavaScript</strong> 实现<strong>Observer模式</strong>。</p></blockquote><h4 id="设计模式中的对象"><a href="#设计模式中的对象" class="headerlink" title="设计模式中的对象"></a>设计模式中的对象</h4><h5 id="Observer-观察者"><a href="#Observer-观察者" class="headerlink" title="Observer 观察者"></a>Observer 观察者</h5><blockquote><p>Observer是一个监视被观察者的对象，它需要提供一个接口，对数据发生改变时，做出的行为进行定义。</p></blockquote><h5 id="Subject-被观察者"><a href="#Subject-被观察者" class="headerlink" title="Subject 被观察者"></a>Subject 被观察者</h5><blockquote><p>在出现观察者关心的事件时，要同时通知多个观察者。</p></blockquote><h4 id="抽象模型的代码实现"><a href="#抽象模型的代码实现" class="headerlink" title="抽象模型的代码实现"></a><u>抽象模型</u>的代码实现</h4><h5 id="Observer-观察者-1"><a href="#Observer-观察者-1" class="headerlink" title="Observer 观察者"></a>Observer 观察者</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 观察者包含一个notify(通知)的回调方法</span></span><br><span class="line">Observer.prototype.notify = <span class="function"><span class="keyword">function</span> (<span class="params">info</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在该方法内做出操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`观察者发现 <span class="subst">$&#123;info&#125;</span> 出现更改`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Subject-被观察者-1"><a href="#Subject-被观察者-1" class="headerlink" title="Subject 被观察者"></a>Subject 被观察者</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Subject = <span class="function"><span class="keyword">function</span> (<span class="params">info</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注册自己（被观察者）的信息</span></span><br><span class="line">    <span class="keyword">this</span>.info = info;</span><br><span class="line">    <span class="comment">// 已经注册的观察者的列表</span></span><br><span class="line">    <span class="keyword">this</span>.observerList = [];</span><br><span class="line">&#125;;</span><br><span class="line">Subject.prototype = &#123;</span><br><span class="line">    <span class="comment">// 注册一个监视当前对象的观察者到观察者列表</span></span><br><span class="line">    register: <span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observerList.push(observer);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 不在关注当前对象的观察者，注销观察者对象</span></span><br><span class="line">    remove: <span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获得当前观察者列表的长度</span></span><br><span class="line">        <span class="keyword">var</span> listLength = <span class="keyword">this</span>.observerList.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listLength; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((observer = <span class="keyword">this</span>.observerList[i])) &#123;</span><br><span class="line">                <span class="comment">// 从观测者列表删除该观察者</span></span><br><span class="line">                <span class="keyword">this</span>.observerList.splice(i, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 通知所有注册的观察者对象</span></span><br><span class="line">    update: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> observer;</span><br><span class="line">        <span class="comment">// 获得当前观察者列表的长度</span></span><br><span class="line">        <span class="keyword">var</span> listLength = <span class="keyword">this</span>.observerList.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listLength; i++) &#123;</span><br><span class="line">            observer = <span class="keyword">this</span>.observerList[i];</span><br><span class="line">            <span class="comment">// 调用Observer对象的notify回调方法</span></span><br><span class="line">            observer.notify(<span class="keyword">this</span>.info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote><p>以上便是Observer模式的代码实现雏形，主要的<strong>流程</strong>和<strong>逻辑</strong>已经包括在其中了。但是在具体实现的时候，可以做出部分的调整。</p></blockquote><p><strong>比如：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observer.notify(<span class="keyword">this</span>.info);</span><br></pre></td></tr></table></figure><blockquote><p>这一句代码可以不一定要传输对象自身的所有信息，放在出版社那，可能只需要传入一个新发布的书名。</p></blockquote><p>那么接下来，我们按照之前的<strong>出版社-书店-读者</strong>的例子，进行一个<strong>具体实例</strong>的代码实现。</p><hr><h4 id="具体实例的代码实现"><a href="#具体实例的代码实现" class="headerlink" title="具体实例的代码实现"></a><u>具体实例</u>的代码实现</h4><h5 id="Observer-观察者-书店-定义"><a href="#Observer-观察者-书店-定义" class="headerlink" title="Observer 观察者(书店) 定义"></a>Observer 观察者(书店) 定义</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BookStore = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 书店包含一个notify(通知)的回调方法</span></span><br><span class="line">BookStore.prototype.notify = <span class="function"><span class="keyword">function</span> (<span class="params">CompanyName,BookName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在该方法内做出操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`读者快来，我这出了新书：<span class="subst">$&#123;CompanyName&#125;</span> 发版的 <span class="subst">$&#123;BookName&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Subject-被观察者-出版社-定义"><a href="#Subject-被观察者-出版社-定义" class="headerlink" title="Subject 被观察者(出版社) 定义"></a>Subject 被观察者(出版社) 定义</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Company = <span class="function"><span class="keyword">function</span> (<span class="params">CompanyName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 出版社名称</span></span><br><span class="line">    <span class="keyword">this</span>.Name = CompanyName;</span><br><span class="line">    <span class="comment">// 新的书名</span></span><br><span class="line">    <span class="keyword">this</span>.NewBookName = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">// 已经注册的书店的列表</span></span><br><span class="line">    <span class="keyword">this</span>.bookStoreList = [];</span><br><span class="line">&#125;;</span><br><span class="line">Company.prototype = &#123;</span><br><span class="line">    <span class="comment">// 注册一个监视当前对象的书店到书店列表</span></span><br><span class="line">    register: <span class="function"><span class="keyword">function</span> (<span class="params">bookStore</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookStoreList.push(bookStore);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 不在关注当前对象的书店，注销书店对象</span></span><br><span class="line">    remove: <span class="function"><span class="keyword">function</span> (<span class="params">bookStore</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 获得当前书店列表的长度</span></span><br><span class="line">        <span class="keyword">var</span> listLength = <span class="keyword">this</span>.bookStoreList.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listLength; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((bookStore == <span class="keyword">this</span>.observerList[i])) &#123;</span><br><span class="line">                <span class="comment">// 从书店列表删除该观察者</span></span><br><span class="line">                <span class="keyword">this</span>.bookStoreList.splice(i, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 通知所有注册的书店对象</span></span><br><span class="line">    publish: <span class="function"><span class="keyword">function</span> (<span class="params">BookName</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 记录新发布书的名字</span></span><br><span class="line">        <span class="keyword">this</span>.NewBookName = BookName;</span><br><span class="line">        <span class="keyword">var</span> bookStore;</span><br><span class="line">        <span class="comment">// 获得当前书店列表的长度</span></span><br><span class="line">        <span class="keyword">var</span> listLength = <span class="keyword">this</span>.bookStoreList.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; listLength; i++) &#123;</span><br><span class="line">            bookStore = <span class="keyword">this</span>.bookStoreList[i];</span><br><span class="line">            <span class="comment">// 调用BookStore对象的notify回调方法</span></span><br><span class="line">            bookStore.notify(<span class="keyword">this</span>.Name,<span class="keyword">this</span>.NewBookName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个出版社——VicoHu出版社</span></span><br><span class="line"><span class="keyword">var</span> company = <span class="keyword">new</span> Company(<span class="string">"VicoHu出版社"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化三家商店</span></span><br><span class="line"><span class="keyword">var</span> bookStore1 = <span class="keyword">new</span> BookStore(<span class="string">"小胡书店"</span>);</span><br><span class="line"><span class="keyword">var</span> bookStore2 = <span class="keyword">new</span> BookStore(<span class="string">"二刘书店"</span>);</span><br><span class="line"><span class="keyword">var</span> bookStore3 = <span class="keyword">new</span> BookStore(<span class="string">"大黄书店"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写bookStore3的notify方法实现发布新书时的不同操作</span></span><br><span class="line">bookStore3.notify = <span class="function"><span class="keyword">function</span> (<span class="params">CompanyName, BookName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在该方法内做出操作</span></span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.Name&#125;</span>促销，新书上架：<span class="subst">$&#123;CompanyName&#125;</span> 发版的 <span class="subst">$&#123;BookName&#125;</span>，比其他的店都要便宜很多。`</span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将三家商店注册到出版社的商店列表里</span></span><br><span class="line">company.register(bookStore1);</span><br><span class="line">company.register(bookStore2);</span><br><span class="line">company.register(bookStore3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布新书</span></span><br><span class="line">company.publish(<span class="string">"《挪威的森林》"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出如下内容</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 小胡书店有促销活动!!!!! 读者快来，我这出了新书：VicoHu出版社 发版的 《挪威的森林》</span></span><br><span class="line"><span class="comment"> * 二刘书店有促销活动!!!!! 读者快来，我这出了新书：VicoHu出版社 发版的 《挪威的森林》</span></span><br><span class="line"><span class="comment"> * 大黄书店促销，新书上架：VicoHu出版社 发版的 《挪威的森林》，比其他的店都要便宜很多。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>在上面的<strong>具体实例</strong>的代码实现中，我们完成了书店的创建，和出版社的创建，并且将多个商店注册到出版社，并在出版社发布新书的时候，通知给所有的商店，让商店发出广告和通知给我们（读者）。<br>其实，从<strong>本质</strong>上而言，商店（<strong>观察者</strong>）是<u><strong>被动</strong></u>的，它需要依赖于出版社（<strong>被观察者</strong>）<strong>调用notify方法</strong>，来完成商店的广告发布。<br>但是，商店的广告的发布，可以通过<u><strong>重写 notify 方法</strong></u>来进行<strong>自定义</strong>的操作。</p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>Observer 设计模式</strong>的<strong>优点</strong>和<strong>缺点</strong>都比较<strong>明显</strong>。</p><h5 id="Observer模式-优点"><a href="#Observer模式-优点" class="headerlink" title="Observer模式 优点"></a>Observer模式 优点</h5><ol><li><strong>解耦</strong>。这是现在大多数的<strong>设计模式</strong>都在做的一件事情，例如：<strong>MVC、MVVM</strong>等。其好处就在于，不需要在设计观察者的时候，关注被观察者的设计。这样可以只需要<strong>关注</strong>一个<strong>notify方法</strong>的<strong>参数</strong>。这样的好处很明显，可以<strong>把更多的注意力放在设计某个对象</strong>的上面。</li><li><strong>广播通讯</strong>。如我们后面发布的 《<strong>挪威的森林</strong>》一书，只需要调用一出版社的<strong>publish方法</strong>，就可以对所有已经在出版社注册的商店进行通知。</li></ol><h5 id="Observer模式-缺点"><a href="#Observer模式-缺点" class="headerlink" title="Observer模式 缺点"></a>Observer模式 缺点</h5><ol><li><strong>观察者过于被动</strong>。观察者在这个设计中，其实更像是个<strong>被通知</strong>的身份，它没有<strong>主动了解</strong>被观察者的能力。只能根据观察者给的信息，做出反应和操作。</li><li><strong>抗风险性不高</strong>。假如某个注册的商店的方法出现问题，或者一直未执行完，会影响到后面的商店的通知。从而影响整体广播的执行。</li></ol><hr><h3 id="最后的总结"><a href="#最后的总结" class="headerlink" title="最后的总结"></a>最后的总结</h3><blockquote><p>这世界上<strong>没有</strong>绝对通用的设计模式，都是<strong>根据任务的需求</strong>，选择<strong>合适</strong>的设计模式。<br>但是，倘若你连某个合适的设计模式都不知道，就会错过一些<strong>事半功倍</strong>的机会。<br>所以，只有不断的去学习，不断走出舒适圈，才能让自己走的更远，并成为一个编码更加高效、稳定的开发者。加油吧！各位！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;通常一个&lt;strong&gt;优秀的项目&lt;/strong&gt;，会使用到很多的&lt;strong&gt;设计模式&lt;/strong&gt;，这些设计模式在我们的解决方案中，会起到&lt;strong&gt;十分重要&lt;/strong&gt;的作用，它的存在，能使项目的&lt;strong&gt;结构&lt;/st
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://www.vicohu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="JavaScript" scheme="https://www.vicohu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/JavaScript/"/>
    
    
      <category term="设计模式" scheme="https://www.vicohu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="JavaScript" scheme="https://www.vicohu.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue中v-for配合key使用的重要性</title>
    <link href="https://www.vicohu.com/Vue%E4%B8%ADv-for%E9%85%8D%E5%90%88key%E4%BD%BF%E7%94%A8%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"/>
    <id>https://www.vicohu.com/Vue%E4%B8%ADv-for%E9%85%8D%E5%90%88key%E4%BD%BF%E7%94%A8%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</id>
    <published>2020-07-12T15:15:21.000Z</published>
    <updated>2020-09-05T11:25:14.056Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 <strong>Vue 官网</strong>的<strong>风格指南</strong>中，有很多对于Vue编码的风格的要求和建议。<br>在这里，主要解释在<strong>编码指南</strong>中，为<strong>优先级A：必要的</strong> 的编码规范的 <u><strong><a href="https://cn.vuejs.org/v2/style-guide/#%E4%B8%BA-v-for-%E8%AE%BE%E7%BD%AE%E9%94%AE%E5%80%BC%E5%BF%85%E8%A6%81" target="_blank" rel="noopener"%3Ehttps://cn.vuejs.org/v2/style-guide/#%E4%B8%BA-v-for-%E8%AE%BE%E7%BD%AE%E9%94%AE%E5%80%BC%E5%BF%85%E8%A6%81">为 v-for 设置键值</a></strong></u></p></blockquote><blockquote><p>相信在编码初期，很多人都不理解 <strong>key</strong> 的作用，因为似乎有与没有，似乎都能完成元素的渲染。（当然，用过 <strong>Vue  CLI</strong>，并设置了 <strong>ESlint</strong> 的朋友，应该会发现 <strong>ESLint</strong> <strong>强制要求</strong>我们在使用 <strong>v-for</strong> 时，加入 <strong>key</strong>，否则在编译阶段会报错）</p><p>在官网文档中，对 <strong>key</strong> 做出的诠释是：</p><blockquote><p>如果不使用 <strong>key</strong>，<strong>Vue</strong> 会使用一种<strong>最大限度减少动态元素</strong>并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 <strong>key</strong> 时，它会基于 <strong>key</strong> 的变化<strong>重新排列元素顺序</strong>，并且会<strong>移除</strong> <strong>key</strong> <strong>不存在</strong>的元素。</p></blockquote></blockquote><p>由官方文档，则说明了 <strong>key</strong> 在 <strong>v-for</strong> 渲染的元素中，主要是作为<strong>唯一标识</strong>去让 <strong>Vue</strong> “认为”每个元素都是<strong>独一无二</strong>的，而不会因为<strong>为了减小渲染</strong>而<strong>复用或修改</strong>之前<strong>相类似</strong>的元素，而导致一些<strong>特殊情况</strong>的出现。</p><h3 id="不使用key的情况"><a href="#不使用key的情况" class="headerlink" title="不使用key的情况"></a>不使用key的情况</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"NewFruitName"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 双向绑定文本框的输入到 NewFruitName --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"NewFruit"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in FruitList"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;input type="checkbox"&gt; &#123;&#123;item.name&#125;&#125; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"Fruit"</span> <span class="attr">type</span>=<span class="string">"radio"</span>&gt;</span> &#123;&#123;item.name&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建 Vue 实例，并将其挂载在id为app的div上</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">            FruitList: [&#123;</span><br><span class="line">                    id: 1,</span><br><span class="line"><span class="actionscript">                    name: <span class="string">'苹果'</span></span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    id: 2,</span><br><span class="line"><span class="actionscript">                    name: <span class="string">'香蕉'</span></span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    id: 3,</span><br><span class="line"><span class="actionscript">                    name: <span class="string">'橘子'</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            NewFruitId: 3,</span><br><span class="line"><span class="actionscript">            <span class="comment">// 目前已存在的最大水果id为3</span></span></span><br><span class="line"><span class="actionscript">            NewFruitName: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 新的水果名</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">// 添加一个新的水果</span></span></span><br><span class="line">            NewFruit() &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.NewFruitId = <span class="keyword">this</span>.NewFruitId + <span class="number">1</span>;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// unshift方法，是Array对象的方法，可向数组的开头添加一个或更多元素，并返回新的长度</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 在这里用该方法，主要是为了凸显出key的作用和效果，无特殊含义</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.FruitList.unshift(&#123;</span></span><br><span class="line"><span class="actionscript">                    id: <span class="keyword">this</span>.NewFruitId,</span></span><br><span class="line"><span class="actionscript">                    name: <span class="keyword">this</span>.NewFruitName</span></span><br><span class="line">                &#125;)</span><br><span class="line"><span class="actionscript">                <span class="comment">// 由于双向绑定的缘故，为了显示效果，在添加完成后，清空输入框的输入文字</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.NewFruitName = <span class="string">''</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试情况"><a href="#测试情况" class="headerlink" title="测试情况"></a>测试情况</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200715230054667.png" alt="初次选中" title="">                </div>                <div class="image-caption">初次选中</div>            </figure><p>在上面这个情况中，当我们<strong>选中</strong>香蕉，<strong>再添加</strong>一个榴莲时，会发现，之前<strong>选中的<u>香蕉</u></strong>，<strong>变为选中<u>苹果</u></strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/2020071523012477.png" alt="无key选中后" title="">                </div>                <div class="image-caption">无key选中后</div>            </figure><p>这显然不是我们想要的效果，我们<strong>预期的效果</strong>是添加一个水果后，之前选中的水果不会变化。</p><hr><h3 id="使用key的情况"><a href="#使用key的情况" class="headerlink" title="使用key的情况"></a>使用key的情况</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"NewFruitName"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 双向绑定文本框的输入到 NewFruitName --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"NewFruit"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in FruitList"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;input type="checkbox"&gt; &#123;&#123;item.name&#125;&#125; --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"Fruit"</span> <span class="attr">type</span>=<span class="string">"radio"</span>&gt;</span> &#123;&#123;item.name&#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 创建 Vue 实例，并将其挂载在id为app的div上</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">            FruitList: [&#123;</span><br><span class="line">                    id: 1,</span><br><span class="line"><span class="actionscript">                    name: <span class="string">'苹果'</span></span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    id: 2,</span><br><span class="line"><span class="actionscript">                    name: <span class="string">'香蕉'</span></span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    id: 3,</span><br><span class="line"><span class="actionscript">                    name: <span class="string">'橘子'</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            NewFruitId: 3,</span><br><span class="line"><span class="actionscript">            <span class="comment">// 目前已存在的最大水果id为3</span></span></span><br><span class="line"><span class="actionscript">            NewFruitName: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 新的水果名</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">// 添加一个新的水果</span></span></span><br><span class="line">            NewFruit() &#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.NewFruitId = <span class="keyword">this</span>.NewFruitId + <span class="number">1</span>;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// unshift方法，是Array对象的方法，可向数组的开头添加一个或更多元素，并返回新的长度</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 在这里用该方法，主要是为了凸显出key的作用和效果，无特殊含义</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.FruitList.unshift(&#123;</span></span><br><span class="line"><span class="actionscript">                    id: <span class="keyword">this</span>.NewFruitId,</span></span><br><span class="line"><span class="actionscript">                    name: <span class="keyword">this</span>.NewFruitName</span></span><br><span class="line">                &#125;)</span><br><span class="line"><span class="actionscript">                <span class="comment">// 由于双向绑定的缘故，为了显示效果，在添加完成后，清空输入框的输入文字</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.NewFruitName = <span class="string">''</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试情况-1"><a href="#测试情况-1" class="headerlink" title="测试情况"></a>测试情况</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200715230304135.png" alt="有key选中后" title="">                </div>                <div class="image-caption">有key选中后</div>            </figure><p>在上面这个情况中，但我们<strong>选中</strong>香蕉，<strong>再添加</strong>一个榴莲时，则没有出现选中的水果错位的情况。这和我们的预期一样。</p><hr><h3 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h3><p>综上所述，使用 <strong>key</strong>，在 <strong>v-for</strong> 渲染的元素中，在某些情况下，出现和预期不一样的效果。<br>这就是因为，在 <strong>Vue渲染</strong> 的时候，<strong>通过只修改元素中的文字，而不重新生成整个元素，来减小渲染强度</strong>（只改变元素的2个文字，再添加一个元素，相比于<strong>摧毁</strong>所有元素，并<strong>重新创建</strong>所有元素，显然是前者渲染强度小一些。）</p><h3 id="关于ESLint的一些观点"><a href="#关于ESLint的一些观点" class="headerlink" title="关于ESLint的一些观点"></a>关于ESLint的一些观点</h3><p>在现在大多数的情况下，我们都会使用 <strong>Vue CLI</strong> 来完成项目，在 <strong>Vue CLI</strong> 中可以选用 <strong>ESLint</strong> 来对代码进行一些格式规范、和编码规范。<br>当然，它有些时候对于编码的格式太过于严苛，而导致很多初期使用的人，会很头疼，这里可以推荐使用 <strong>VSCode</strong> 配合<br><strong>Prettier</strong> 插件，在保存时，进行<strong>自动格式调整</strong>。减小在格式调整上花的时间，又同时可以让 <strong>ESLint</strong> 对编码进行一些检测，比如上面的例子，在 <strong>v-for</strong> 中，不使用 <strong>key</strong>，则会<strong>不通过检测</strong>，并<strong>给出</strong>相应的<strong>提示</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在 &lt;strong&gt;Vue 官网&lt;/strong&gt;的&lt;strong&gt;风格指南&lt;/strong&gt;中，有很多对于Vue编码的风格的要求和建议。&lt;br&gt;在这里，主要解释在&lt;strong&gt;编码指南&lt;/strong&gt;中，为&lt;strong&gt;优先级A：必要的&lt;/
      
    
    </summary>
    
    
      <category term="Vue" scheme="https://www.vicohu.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://www.vicohu.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue中v-if和v-show的区别和使用场景</title>
    <link href="https://www.vicohu.com/Vue%E4%B8%ADv-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://www.vicohu.com/Vue%E4%B8%ADv-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2020-07-05T10:19:21.000Z</published>
    <updated>2020-09-05T11:25:14.056Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们在学习Vue的时候，肯定产生过对 <strong>v-if</strong> 和 <strong>v-show</strong> 的区别存在疑惑。在不深入到渲染逻辑的情况下，大到时候，给开发者的<strong>直观感受</strong>都是一样的：<strong>显示和不显示</strong>。但在实现的本质上，是有差别的。</p></blockquote><blockquote><p>其实在Vue的官方文档中，也有做出一些相应的解释。</p></blockquote><h3 id="概念和区别"><a href="#概念和区别" class="headerlink" title="概念和区别"></a>概念和区别</h3><h4 id="官方文档概念"><a href="#官方文档概念" class="headerlink" title="官方文档概念"></a>官方文档概念</h4><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><blockquote><p>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。<br>1</p></blockquote><h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><blockquote><p><strong>v-show</strong> 的元素始终会被渲染并保留在 DOM 中。<strong>v-show</strong> 只是简单地切换元素的 CSS property <strong>display</strong>。</p></blockquote><hr><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>根据以上的官方文档，其实就已经表明出了其背后的渲染逻辑。</p><p><strong>v-if</strong> 是根据表达式返回的值，来判断是否渲染，更准确的说是，假如<strong>表达式返回值</strong>为 <strong>false</strong>，则直接跳过该元素及其子元素的渲染，根本<strong>不消耗资源</strong>去生成相应的 <strong>Virtual DOM</strong>。换句话说，<strong>v-if</strong> 的表达式返回值，会直接触发到 <strong>当前组件</strong> <strong>生命周期</strong>，并且<strong>事件监听器</strong>和<strong>子组件</strong>会被适当地<strong>被销毁和重建</strong>。<br>所以，可以理解为 <strong>v-if</strong> 是<strong>惰性</strong>的，他不会在页面初始化时，被<strong>无条件</strong>渲染，而是<strong>按需</strong>响应式地渲染。</p><p>而 <strong>v-show</strong> ，这是无论<strong>表达式返回值</strong>是否是 true 都会在 <strong>create</strong> 生命周期，<strong>无条件消耗资源</strong>生成对应的 <strong>Virtual DOM</strong>，并挂载到HTML页面中，只是再根据表达式返回值，切换 <strong>display</strong> 这个 <strong>CSS</strong> 属性。</p><hr><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>从页面显示上看，二者并没有太多的区别，基本上就是显示和不显示的用户体验差别。<br>在<strong>需要频繁切换显示状态</strong>的组件或者<strong>相对渲染强度大但是过分依赖生命周期或</strong>的组件，更加适合用 <strong>v-show</strong> 作为切换的指令。<br>因为，<strong>v-if</strong> 会带来实时渲染所带来的不必要的资源消耗，和操作延迟，这给用户的体验并不是很好，相对下，<strong>v-show</strong>基于CSS的显示与隐藏，更加快捷，响应速度更快，并且资源消耗也会更小。<br>但 <strong>v-show</strong> 的弱点也很明显，因为页面是在页面初始化的时候，就得完成全部的渲染，这使得页面的加载会更消耗资源，也意味着<strong>页面加载时长会相应增长</strong>。假如组件对资源的消耗，已经影响到了用户的体验，可能采取 <strong>v-if</strong> 将组件分成小块，按需加载或许会更加有用户体验。</p><p>总而言之，<strong>v-if</strong> 是在表达式返回值切换时，才渲染和摧毁组件及其子组件，他会触发组件的生命周期。而 <strong>v-show</strong> 是在页面初始化时就进行了完整的渲染，这会在某些情况下，明显增加页面的加载时间。具体的使用，还得根据<strong>需求</strong>、<strong>页面的加载时长</strong>以及<strong>组件的渲染强度</strong>，进行合适的选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们在学习Vue的时候，肯定产生过对 &lt;strong&gt;v-if&lt;/strong&gt; 和 &lt;strong&gt;v-show&lt;/strong&gt; 的区别存在疑惑。在不深入到渲染逻辑的情况下，大到时候，给开发者的&lt;strong&gt;直观感受&lt;/strong&gt;都是一样
      
    
    </summary>
    
    
      <category term="Vue" scheme="https://www.vicohu.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://www.vicohu.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>.Net Core3.1 WebAPI CORS跨域配置——踩坑</title>
    <link href="https://www.vicohu.com/net%20core3.1%20CORS%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E8%B8%A9%E5%9D%91/"/>
    <id>https://www.vicohu.com/net%20core3.1%20CORS%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E8%B8%A9%E5%9D%91/</id>
    <published>2020-06-23T09:35:42.000Z</published>
    <updated>2020-09-05T11:25:14.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前在用Vue开发的过程中，使用到了.Net Core 3.1 的 WebAPI，然后必然要解决一个 CORS 跨域的问题。<br>根据百度，学习到了配置配置跨域的方法。一运行项目访问接口，就直接在Startup类中直接报错</p></blockquote><h4 id="报错异常如下图"><a href="#报错异常如下图" class="headerlink" title="报错异常如下图"></a>报错异常如下图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.InvalidOperationException</span><br><span class="line">  HResult&#x3D;0x80131509</span><br><span class="line">  Message&#x3D;The CORS protocol does not allow specifying a wildcard (any) origin and credentials at the same time. Configure the CORS policy by listing individual origins if credentials needs to be supported.</span><br><span class="line">  Source&#x3D;Microsoft.AspNetCore.Cors</span><br></pre></td></tr></table></figure><hr><p>其实解决方案也很简单：</p><ol><li>在Startup类的ConfigureServices方法中添加如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加cors 服务 配置跨域处理   </span><br><span class="line">services.AddCors(options &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">     options.AddPolicy(&quot;any&quot;, builder &#x3D;&gt;</span><br><span class="line">     &#123;</span><br><span class="line">          builder.WithMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;HEAD&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)</span><br><span class="line">          &#x2F;&#x2F;.AllowCredentials()&#x2F;&#x2F;指定处理cookie</span><br><span class="line">          .AllowAnyOrigin(); </span><br><span class="line">          &#x2F;&#x2F;允许任何来源的主机访问</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>在Startup类的Configure方法中添加如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.UseCors(&quot;any&quot;);</span><br><span class="line">&#x2F;&#x2F; 注意，这一行代码一定要写在 app.UseAuthorization(); 的下面，否则会报错的。</span><br></pre></td></tr></table></figure><blockquote><p>以上就是 .Net Core3.1 CORS跨域配置的解决方案。</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;之前在用Vue开发的过程中，使用到了.Net Core 3.1 的 WebAPI，然后必然要解决一个 CORS 跨域的问题。&lt;br&gt;根据百度，学习到了配置配置跨域的方法。一运行项目访问接口，就直接在Startup类中直接报错&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="C#" scheme="https://www.vicohu.com/categories/C/"/>
    
      <category term=".Net" scheme="https://www.vicohu.com/categories/C/Net/"/>
    
      <category term=".Net Core3.1" scheme="https://www.vicohu.com/categories/C/Net/Net-Core3-1/"/>
    
    
      <category term="WebAPI" scheme="https://www.vicohu.com/tags/WebAPI/"/>
    
      <category term=".Net Core3.1" scheme="https://www.vicohu.com/tags/Net-Core3-1/"/>
    
  </entry>
  
  <entry>
    <title>.gitignore 无效的解决方案</title>
    <link href="https://www.vicohu.com/gitignore%20%E6%97%A0%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://www.vicohu.com/gitignore%20%E6%97%A0%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2020-06-21T07:30:26.000Z</published>
    <updated>2020-09-05T11:25:14.056Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们在使用git的时候，经常会使用.gitignore文件，定义规则，对项目文件进行上传筛选<br>但在某些时候，我们可能会出现在项目已经创建，或者项目的中途，创建该文件，而导致的改文件无法生效的情况。</p></blockquote><p>这是因为 .gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。<br>我们可以尝试用清除本地缓存的方法，解决该问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;update .gitignore&quot;</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们在使用git的时候，经常会使用.gitignore文件，定义规则，对项目文件进行上传筛选&lt;br&gt;但在某些时候，我们可能会出现在项目已经创建，或者项目的中途，创建该文件，而导致的改文件无法生效的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这
      
    
    </summary>
    
    
      <category term="Git" scheme="https://www.vicohu.com/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.vicohu.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>C# .Net CodeFist编码基础流程</title>
    <link href="https://www.vicohu.com/CSharp%20.Net%20CodeFist%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/"/>
    <id>https://www.vicohu.com/CSharp%20.Net%20CodeFist%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/</id>
    <published>2020-06-17T10:20:21.000Z</published>
    <updated>2020-09-05T11:25:14.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Code-First-基础流程"><a href="#Code-First-基础流程" class="headerlink" title="Code First 基础流程"></a>Code First 基础流程</h2><blockquote><p><strong>1. 定义好实体类（对应数据库的表及其字段）</strong></p></blockquote><blockquote><p><strong>2. 定义好上下文操作类（以context结尾）</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在该项目上右键找到“管理 NuGet程序包” 搜索EntityFrameWork并下载好</span><br><span class="line"></span><br><span class="line">public nCovContext() : base(&quot;name&#x3D;aa&quot;) &#x2F;&#x2F; 声明连接字符串</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注册实体类 </span><br><span class="line">public DbSet&lt;tbStudent&gt; tbStudent &#123; get; set; &#125;</span><br><span class="line">public DbSet&lt;tbTeacher&gt; tbTeacher &#123; get; set; &#125;</span><br><span class="line">public DbSet&lt;tbDetail&gt; tbDetail &#123; get; set; &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>3. 在App.config里加上数据库连接字符串</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;connectionStrings&gt;</span><br><span class="line">        &lt;add name&#x3D;&quot;aa&quot; connectionString&#x3D;&quot;server&#x3D;.;database&#x3D;nCov3804DB;uid&#x3D;sa;pwd&#x3D;123456&quot;    providerName&#x3D;&quot;System.Data.SqlClient&quot;  &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;connectionStrings&gt;</span><br></pre></td></tr></table></figure><p>【注意: 上下文操作类的构造方法的name=”aa”要与App.config的name=aa保持一致】</p><hr><h2 id="Code-First模式默认的约定"><a href="#Code-First模式默认的约定" class="headerlink" title="Code First模式默认的约定"></a><strong>Code First模式默认的约定</strong></h2><ol><li><p><strong>主键约定</strong>： 以ID或者是类型ID的字段会自动生成为主键。如果是Int类型，会默认为自增</p></li><li><p><strong>表名约定</strong>：跟类名一样，会默认加上一个s</p></li><li><p><strong>一对多的约定</strong>：导航属性。</p></li><li><p><strong>字符串约定</strong>：string =&gt; nvarchar(Max),默认允许为空</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Code-First-基础流程&quot;&gt;&lt;a href=&quot;#Code-First-基础流程&quot; class=&quot;headerlink&quot; title=&quot;Code First 基础流程&quot;&gt;&lt;/a&gt;Code First 基础流程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
    
      <category term="C#" scheme="https://www.vicohu.com/categories/C/"/>
    
      <category term=".Net" scheme="https://www.vicohu.com/categories/C/Net/"/>
    
    
      <category term="C#" scheme="https://www.vicohu.com/tags/C/"/>
    
      <category term=".Net" scheme="https://www.vicohu.com/tags/Net/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——打家劫舍问题——动态规划</title>
    <link href="https://www.vicohu.com/LeetCode%E2%80%94%E2%80%94%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://www.vicohu.com/LeetCode%E2%80%94%E2%80%94%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-05-27T13:27:27.000Z</published>
    <updated>2020-09-05T11:25:14.056Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="打家劫舍问题"><a href="#打家劫舍问题" class="headerlink" title="打家劫舍问题"></a>打家劫舍问题</h4><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p></blockquote><blockquote><p><strong>示例 1:</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure><blockquote><p><strong>示例 2:</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</span><br></pre></td></tr></table></figure><hr><blockquote><p>对于求最优解得题目，我编码效率最快的，自然是递归，但是，递归在数组的长度越来越长是，所需的世界也会飞速增长。因为递归进行了很多重复的运算。<br>对于本题而言，或许动态规划更加适合当前题目的情景。根据题目规则我们可以得到几个信息。</p></blockquote><blockquote><p><strong><em>Opt[i] = （ Opt[i - 2] + Nums[i] ）</em></strong> <strong><u>或者</u></strong> <strong><em>（Opt[i - 1]）</em></strong></p></blockquote><blockquote><p>i为第i个元素，opt[i]为第i个及其之前的元素的最优解（不考虑之后的元素，只考虑当前元素和之前的元素），Nums为传入的数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化2个变量，代表着选取该节点和不选取该节点。y: yes, n: no</span></span><br><span class="line">        <span class="keyword">int</span>[] opt = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 初始化一个数组，用于存储每个节点的当前元素及其之前元素的最优解（不管之后的元素 是否选择）</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果传入的数组为空，返回值为0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果传入的值为1，返回值为当前数组的唯一元素</span></span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果，满足传入数组的长度大于等于2</span></span><br><span class="line">        opt[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        opt[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 第一个元素及之前元素的最优解为第一个元素本身</span></span><br><span class="line">        <span class="comment">// 第二个元素及之前元素的最优解为第一个元素或者第二个元素（取大值）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= nums.length - <span class="number">1</span>; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 循环计算，2和2之后每一个元素及之前元素的最优解</span></span><br><span class="line">            <span class="comment">// 每个节点都会遇到2个可能，需要当前元素和不需要当前元素</span></span><br><span class="line">            y = nums[i] + opt[i - <span class="number">2</span>];</span><br><span class="line">            n = opt[i - <span class="number">1</span>];</span><br><span class="line">            opt[i] = Math.max(y,n);</span><br><span class="line">            <span class="comment">// 取最优解</span></span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(opt);</span><br><span class="line">        <span class="comment">// 对最优解进行排序，取最大值即为当前题目的最优解</span></span><br><span class="line">        <span class="keyword">return</span> opt[nums.length - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 返回排序后最后一个元素（最大的元素）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;打家劫舍问题&quot;&gt;&lt;a href=&quot;#打家劫舍问题&quot; class=&quot;headerlink&quot; title=&quot;打家劫舍问题&quot;&gt;&lt;/a&gt;打家劫舍问题&lt;/h4&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一
      
    
    </summary>
    
    
      <category term="算法" scheme="https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="Java" scheme="https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/Java/"/>
    
    
      <category term="Java" scheme="https://www.vicohu.com/tags/Java/"/>
    
      <category term="LeetCode" scheme="https://www.vicohu.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://www.vicohu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.vicohu.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode——会议室 II——动态规划</title>
    <link href="https://www.vicohu.com/LeetCode%E2%80%94%E2%80%94%E4%BC%9A%E8%AE%AE%E5%AE%A4%20II%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://www.vicohu.com/LeetCode%E2%80%94%E2%80%94%E4%BC%9A%E8%AE%AE%E5%AE%A4%20II%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2020-05-26T07:51:22.000Z</published>
    <updated>2020-09-05T11:25:14.055Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="会议室-II"><a href="#会议室-II" class="headerlink" title="会议室 II"></a>会议室 II</h4><p>给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si &lt; ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。</p></blockquote><blockquote><p><strong>示例 1:</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [[0, 30],[5, 10],[15, 20]]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><blockquote><p><strong>示例 2:</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [[7,10],[2,4]]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><hr><blockquote><p>这个题目有点类似于上下车问题。本题是规划的对于时间冲突的解决方案。<br>根据题目，我们发现，并不需要在意该会议持续时间。因为会议时间已经固定了，所以我们只需要关注会议室及其会议结束时间即可。因为只有会议时间结束，才能进行下一个会议。否则，这需要开一个新的会议室，去进行会议。为了最优开会成本和时间效率，下一个会议进入的房间，根据会议室结束时间和该会议开始时间的差决定，时间差越小，开会越能“无缝连接”，于是效率越高。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length ==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 根据会议开始时间，数组的重新排序（开始时间的从小到大）</span></span><br><span class="line">        Arrays.sort(intervals,<span class="keyword">new</span> Comparator&lt;&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1[<span class="number">0</span>]-o2[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 定义一个HashMap记录会议室及其结束时间</span></span><br><span class="line">        Map&lt;Integer,Integer&gt; RoomTime = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 第一个开始会议的已经毋庸置疑，就是开会时间最早的那个会议，也就是排序后的第一个会议</span></span><br><span class="line">        RoomTime.put(<span class="number">1</span>,intervals[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 定义一个表示符号，用于后面的forEach跳过第一个会议，因为第一个会议已经安排好了</span></span><br><span class="line">        <span class="keyword">boolean</span> isFirst = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] item :intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isFirst)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 跳过第一个会议，因为已经安排了</span></span><br><span class="line">                isFirst = !isFirst;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 时间差</span></span><br><span class="line">            <span class="keyword">int</span> fix = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 该会议，目前临时安排的房间</span></span><br><span class="line">            <span class="keyword">int</span> tempRoom = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 循环所有会议室</span></span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry: RoomTime.entrySet())&#123;</span><br><span class="line">                <span class="comment">// 如果时间上满足要求</span></span><br><span class="line">                <span class="keyword">if</span>(entry.getValue() &lt;= item[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 取最优的会议室给当前会议</span></span><br><span class="line">                    <span class="keyword">if</span>(fix == <span class="number">0</span> || item[<span class="number">0</span>] - entry.getValue() &lt;= fix)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fix = item[<span class="number">0</span>] - entry.getValue();</span><br><span class="line">                        tempRoom = entry.getKey();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果临时间号不为0，则有房间满足要求。否则，说明没有房间满足要求，需要开一个新的会议室，安排该会议</span></span><br><span class="line">            <span class="keyword">if</span>(tempRoom != <span class="number">0</span>)</span><br><span class="line">                RoomTime.put(tempRoom, item[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                RoomTime.put(RoomTime.size() + <span class="number">1</span>,item[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后返回房间的数量，即是本题的答案</span></span><br><span class="line">        <span class="keyword">return</span> RoomTime.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;会议室-II&quot;&gt;&lt;a href=&quot;#会议室-II&quot; class=&quot;headerlink&quot; title=&quot;会议室 II&quot;&gt;&lt;/a&gt;会议室 II&lt;/h4&gt;&lt;p&gt;给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1]
      
    
    </summary>
    
    
      <category term="算法" scheme="https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="Java" scheme="https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/Java/"/>
    
    
      <category term="Java" scheme="https://www.vicohu.com/tags/Java/"/>
    
      <category term="LeetCode" scheme="https://www.vicohu.com/tags/LeetCode/"/>
    
      <category term="算法" scheme="https://www.vicohu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://www.vicohu.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>教你如何快速刷网课</title>
    <link href="https://www.vicohu.com/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%B7%E7%BD%91%E8%AF%BE/"/>
    <id>https://www.vicohu.com/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%B7%E7%BD%91%E8%AF%BE/</id>
    <published>2020-05-22T10:20:21.000Z</published>
    <updated>2020-09-09T11:59:31.430Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这段时间，疫情之下，直播课、网课，得到了空前的发展和壮大。<br>并且应运出很多奇葩的课程，“大学生体育”，里面教你怎么打篮球，怎么打羽毛球，然而，却根本没人可以在家中完成以上联系。“体育”竟然变成了一种偏理论的课程，并且长达十几个小时。实在诙谐。</p></blockquote><p>于是，在朋友的介绍下，我得知了一个惊天地泣鬼神的<strong>快速刷完网课</strong>的方式——“<strong>代刷网课</strong>“.</p><h2 id="代刷网课"><a href="#代刷网课" class="headerlink" title="代刷网课"></a>代刷网课</h2><p>“<strong>代刷网课</strong>”这个产业，在疫情期间，得到了越多人的认可。因为他可以为学生<strong>节省很多的时间</strong>，去完成一些他们愿意做的事情，比如我放弃了奇葩的”大学生体育”，学习Vue3和Nuxt.js，这十几个小时，可以完成太多的事情。而请”<strong>代刷</strong>“的成本，却不过2-3元不等，何乐而不为呢？</p><blockquote><p>我相信大多数人都明白，有些课程的意义是真的对于<strong>不感兴趣</strong>的人而言，是<strong>没有价值</strong>的。只会增加大学的心理负担。而刷网课，虽然表面不光鲜亮丽，但却是一种<strong>很好的方式</strong>，去<strong>节省</strong>我们大学期间宝贵的时间。我们可以拿着十几到几十小时不等的时间，去<strong>学习自己喜欢的事情</strong>，或者和室友朋友花这时间去聊天、娱乐<br><br><strong>毕竟大学不仅是学习专业知识，更多的是锻炼人际交往的能力。这是进入社会必会的技能</strong>。</p></blockquote><h2 id="怎样代刷网课"><a href="#怎样代刷网课" class="headerlink" title="怎样代刷网课"></a>怎样代刷网课</h2><p>在我的朋友的介绍下，我得知一个<strong>专业刷网课</strong>的平台，这个<strong>刷网课平台</strong>是他和几个<strong>计算机软件技术专业</strong>的朋友，共同搭建和完成的，并且在<strong>运营</strong>发现<strong>月收益可以大于月成本</strong>后，他们便一直在维护这个网站的运行，并维护着<strong>刷网课脚本</strong>的功能。运行至今也有3年的时间了。</p><p>刷网课平台地址：<a href="http://wk.vicohu.com" target="_blank" rel="noopener">点击进入，VicoHu刷网课平台</a></p><ol><li>点击上面链接，进入刷网课平台</li><li>你会看到到如下页面：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200521235619641.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1Mjc2ODQ4,size_16,color_FFFFFF,t_70#pic_center" alt="VicoHu网课刷网课平台" title="">                </div>                <div class="image-caption">VicoHu网课刷网课平台</div>            </figure></li><li>然后，我们点击<strong>蓝色按钮</strong>的<strong>提交课程</strong><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200521235854340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1Mjc2ODQ4,size_16,color_FFFFFF,t_70#pic_center" alt="VicoHu网课刷网课平台" title="">                </div>                <div class="image-caption">VicoHu网课刷网课平台</div>            </figure></li><li>至于选择点击哪一个，则需要依照你需要刷的网课的平台来，例如：<strong>超星学习通</strong>、<strong>智慧树/知到</strong>，这些均在<strong>爆单网课平台</strong>中。</li><li>我们拿<strong>超星学习通</strong>为例，进入后选择<strong>学习通/超星</strong>，并<strong>填写相关信息</strong>，和<strong>下单数量（一科一份，多科多份）</strong><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200522000409297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1Mjc2ODQ4,size_16,color_FFFFFF,t_70#pic_center" alt="VicoHu网课刷网课平台" title="">                </div>                <div class="image-caption">VicoHu网课刷网课平台</div>            </figure></li><li>然后点击<strong>查询课程</strong>，会弹出一个提示框，我们点击<strong>确定</strong>按钮<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200522000722129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1Mjc2ODQ4,size_16,color_FFFFFF,t_70#pic_center" alt="VicoHu网课刷网课平台" title="">                </div>                <div class="image-caption">VicoHu网课刷网课平台</div>            </figure></li><li>点击上图<strong>确定</strong>后，耐心等待片刻，会再次弹出一个框，勾选<strong>要刷的网课</strong>，再“<strong>确认选择</strong>”，然后点击“<strong>立刻购买</strong>”即可。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200522001313497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1Mjc2ODQ4,size_16,color_FFFFFF,t_70#pic_center" alt="VicoHu网课刷网课平台" title="">                </div>                <div class="image-caption">VicoHu网课刷网课平台</div>            </figure></li><li>然后，便根据下方的提示，不要在手机或电脑上频繁登录账号，一般网课根据时长1-3天不等，便可以刷完。</li><li>在选择商品时，可以看到有“<strong>代刷</strong>”，“<strong>高质量代刷</strong>”和”<strong>秒刷 超级速</strong>“， 3种类别，”<strong>代刷</strong>“就是最普通的刷网课，速度中等一般2-3天刷完，相对比较稳定。“<strong>高质量代刷</strong>”。是销量最好的，也是老用户最喜欢的刷课选项，速度1-2天左右刷完，速度相对较快，<strong>极其稳定</strong>，上线至今<strong>0失误</strong>。”<strong>秒刷 超级速</strong>“这款是针对<strong>网课快要截止</strong>的用户，可以在<strong>几小时到半天</strong>时间内<strong>刷完网课</strong>，速度极快。</li></ol><h2 id="为什么要代刷网课，为什么出现代刷网课（我的一点思考和见解）"><a href="#为什么要代刷网课，为什么出现代刷网课（我的一点思考和见解）" class="headerlink" title="为什么要代刷网课，为什么出现代刷网课（我的一点思考和见解）"></a>为什么要代刷网课，为什么出现代刷网课（我的一点思考和见解）</h2><p>本质上，<strong>学生</strong>想<strong>刷网课</strong>嘛？其实是不想的，他们心里会背负一种<strong>内疚感</strong>。如果你里面放的是他们<strong>想要的东西</strong>，<strong>感兴趣的东西</strong>，或者是真的<strong>对未来有可见价值的东西</strong>，我相信<strong>绝大部分人</strong>都<strong>不会拒绝</strong>。<strong>代刷网课</strong>只是一种节省掉<strong>低效时间</strong>、<strong>低价值时间</strong>的<strong>工具</strong>。工具本身又怎么会有错呢。</p><blockquote><p><strong>代刷网课</strong>，在我朋友那是<strong>副业</strong>，在大学生那是<strong>工具</strong>，而对于我而言是一种<strong>新的思考</strong>。</p></blockquote><p>思考为什么网课里会出现这样没有什么价值的课程，却依旧有着和其他重要的课程一样的学分？<br>思考为什么我们喊着<strong>反对应试教育</strong>，要<strong>因材施教</strong>的情况下，却依旧在网课这没有改善。</p><p>我们<strong>中国的大学教育者</strong>是不是该<strong>反思</strong>，而不是抱着一种，只要学生看完了，自己任务就完成的心态，去教育学生。而应该更多的去思考，怎么让把一个可能学生<strong>不兴趣但一定有价值</strong>的课程，变得<strong>有趣</strong>，变得<strong>更有价值</strong>，变得让学生<strong>更容易接受</strong>。我相信，教育的方向绝对不是说让大学生依靠自己的“自觉”去学习。这不过是大学教师给自己台阶，给自己不认真备课的借口。</p><p>我承认教育者，有他的辛苦之处，可是哪个行业不辛苦呢？我们软件工程师经常的996，却很多时候拿着和大学的老师有着差不多的工资。但我们会说不加班了吗？不会，因为我们知道，我们不996就意味着，我们丢失了工作，意味着我们不知道下一顿饭在哪。</p><blockquote><p>我们都应该，为自己的职位的职责付出<strong>应该的努力</strong>。<br>同样，大学生也该为自己省略那些观看对于自己低价值课程的时间。去做自己喜欢的事情，去做有价值的事情，去做那个追逐自己内心的自己。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这段时间，疫情之下，直播课、网课，得到了空前的发展和壮大。&lt;br&gt;并且应运出很多奇葩的课程，“大学生体育”，里面教你怎么打篮球，怎么打羽毛球，然而，却根本没人可以在家中完成以上联系。“体育”竟然变成了一种偏理论的课程，并且长达十几个小时。实在诙谐。
      
    
    </summary>
    
    
      <category term="小技巧" scheme="https://www.vicohu.com/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="刷网课" scheme="https://www.vicohu.com/tags/%E5%88%B7%E7%BD%91%E8%AF%BE/"/>
    
      <category term="大学生刷网课" scheme="https://www.vicohu.com/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%88%B7%E7%BD%91%E8%AF%BE/"/>
    
  </entry>
  
</feed>
