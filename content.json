{"meta":{"title":"VicoHu-个人博客","subtitle":"用程序员的眼光，戏剧地看待世界","description":"VicoHu，一个有导演梦的程序员","author":"VicoHu","url":"https://www.vicohu.com","root":"/"},"pages":[{"title":"categories","date":"2020-05-22T08:07:37.000Z","updated":"2020-09-05T11:25:14.057Z","comments":false,"path":"categories/index.html","permalink":"https://www.vicohu.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-22T08:06:21.000Z","updated":"2020-09-05T11:25:14.058Z","comments":false,"path":"tags/index.html","permalink":"https://www.vicohu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C# 索引器","slug":"CSharp 索引器 ","date":"2020-08-23T09:20:45.000Z","updated":"2020-09-09T12:11:11.423Z","comments":true,"path":"CSharp 索引器 /","link":"","permalink":"https://www.vicohu.com/CSharp%20%E7%B4%A2%E5%BC%95%E5%99%A8%20/","excerpt":"","text":"索引器的定义 索引器允许类或结构的实例就像数组一样进行索引。 无需显式指定类型或实例成员，即可设置或检索索引值。 索引器类似于属性，不同之处在于它们的访问器需要使用参数。 索引器的使用场景 不知道各位是否有遇到过这样一种情况，我们基于一个类或继承于同一个父类或接口的类，实例化多个对象，却无法进行统一的管理和定义。即使是利用 List 进行管理，依旧有很多不方便和局限的地方。 索引器的出现，就是为了解决这个问题，它允许类或结构的实例就像数组一样进行索引。 索引器的 C# 实现简单例子定义索引器12345678910111213141516// 定一个索引器SimpleCollectionpublic class SimpleCollection&lt;T&gt;&#123; // 定一个数组，转载这些传入的数据 private T[] arr = new T[100]; // 定义一个属性，用于获取数组的长度 public int Length =&gt; arr.Length; // 定义一个索引器，允许使用[]对数据进行索引 public T this[int i] &#123; get =&gt; arr[i]; set =&gt; arr[i] = value; &#125;&#125; 定义一个需要使用索引器的类123456789// 定义一个Car类public class Car&#123; public string name; public Car(string name) &#123; this.name = name; &#125;&#125; 索引器的使用12345678910111213141516171819202122public static void Main(string[] args)&#123; SimpleCollection&lt;Car&gt; simple = new SimpleCollection&lt;Car&gt;(); simple[0] = new Car(\"Car\"); simple[1] = new Car(\"Car1\"); simple[2] = new Car(\"Car2\"); simple[3] = new Car(\"Car3\"); simple[4] = new Car(\"Car4\"); for (int i = 0; i &lt; simple.Length; i++) &#123; Console.WriteLine(simple[i].name); &#125;&#125;/*输出以下内容：CarCar1Car2Car3Car4*/ 索引器实际使用 在更多的时候，我们不会像上面的实例一样去写索引器。更多的时候，是索引器的定义内，加入一些对数据进行处理的方法。 例如上面的例子，我们希望可以讲输出car属性的方法，内置在索引器内。 定义新的索引器123456789101112131415161718192021222324252627// 定一个索引器SimpleCollectionpublic class SimpleCollection&lt;T&gt; where T:Car&#123; // 定一个数组，转载这些传入的数据 private T[] arr = new T[100]; // 定义一个属性，用于获取数组的长度 public int Length =&gt; arr.Length; // 定义一个索引器，允许使用[]对数据进行索引 public T this[int i] &#123; get =&gt; arr[i]; set =&gt; arr[i] = value; &#125; /// &lt;summary&gt; /// 输出所有方法的name属性的值 /// &lt;/summary&gt; public void SayAllName() &#123; for (int i = 0; i &lt; arr.Length; i++) &#123; Console.WriteLine(arr[i].name); &#125; &#125;&#125; 上面这段新的代码，除了新增了一个 SayAllName 的方法之外，还有一个细节，在第一行，多了个 where T : Car，这个是为了约束这个索引器的泛型只能是继承于 Car 的类。这样，就相当于，告诉当前索引器，索引器索引的实例继承于 Car 类，所以可以在使用 Car 所允许继承的方法和属性。 索引器的使用12345678910111213141516171819public static void Main(string[] args)&#123; SimpleCollection&lt;Car&gt; simple = new SimpleCollection&lt;Car&gt;(); simple[0] = new Car(\"Car\"); simple[1] = new Car(\"Car1\"); simple[2] = new Car(\"Car2\"); simple[3] = new Car(\"Car3\"); simple[4] = new Car(\"Car4\"); simple.SayAllName();&#125;/*输出以下内容：CarCar1Car2Car3Car4*/ 由此可见，依旧可以完成我们预期的任务。但这样，可以让主函数的逻辑更加清晰明了，也方便了继承于 Car 或 Car类 的所有实例，可以使用他们共用的一种方法 SayAllName。这能大大加快了我们的编码效率。 所以，建议在日常的开发中，对需要一起操作的多个同父的类，多使用索引器，加快自己的开发效率。","categories":[{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/tags/C/"}]},{"title":"JavaScript设计模式——Observe模式（观察者模式）","slug":"JavaScript设计模式——Observe模式（观察者模式）","date":"2020-07-17T12:15:21.000Z","updated":"2020-09-05T11:25:14.055Z","comments":true,"path":"JavaScript设计模式——Observe模式（观察者模式）/","link":"","permalink":"https://www.vicohu.com/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Observe%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89/","excerpt":"","text":"通常一个优秀的项目，会使用到很多的设计模式，这些设计模式在我们的解决方案中，会起到十分重要的作用，它的存在，能使项目的结构更加简洁、清晰、易于理解。所以了解常用的设计模式，会让我们在日常开发更加得心应手，也会让团队沟通变得更加顺畅。在《设计模式：可复用面向对象软件基础》一书中强调：当我们评估一个面向对象系统的质量时，所使用的方法之一就是判断系统的设计者是否强调了对象之间的公共系统关系。 简介那么在当前这个博文中，我介绍的就是 JavaScript 语言的 Observer设计模式。初次接触 Observer设计模式，是在 Vue 的双向数据绑定中。其原理就是使用了 Observer-观察者 对数据进行劫持，然后让数据的读写全部处于监管之中。然后再使用发布-订阅模式的Publish-发布者通知到Subscribe-订阅者，对数据进行进行相应操作，比如双向数据绑定中的视图更新。 所以，Vue的一个数据的写入，要经过这样一个流程。 流程图 所以，实际上，Vue 数据的双向绑定，使用到了2个设计模式：Obsever模式和Publish–Subscribe模式。(有一些人认为，观察者模式和订阅观察模式是一个模式，其实不然，他们还是有一些区别的) Observer模式（观察者模式） 就像发明一个新的东西一样，新的发明，必定会有其在现实世界的启发。就好比雷达的发明，源自于蝙蝠的超声波回声定位。火箭的发明，源自于水母、墨鱼的反冲运动。 无独有偶，观察者模式也一样。在现实社会中，经常会出现观察者这个身份。比如书店，他们就是观察者。既然，有了观察者，那一定会有被观察者，他们就像是出版社。书店“监视”各个出版社的新书，若出版社出现了新书（观察者在监视的行为），则书店获得了出版社的信息（被观察者的对象信息）和出版社的发布新书（被观察者的变化），然后书店将其发布的新书拿到，并告诉关注该类书的读者（观察者做出相应操作） Observer模式的大致流程如上。话不多说，我们着手开始用 JavaScript 实现Observer模式。 设计模式中的对象Observer 观察者 Observer是一个监视被观察者的对象，它需要提供一个接口，对数据发生改变时，做出的行为进行定义。 Subject 被观察者 在出现观察者关心的事件时，要同时通知多个观察者。 抽象模型的代码实现Observer 观察者123456var Observer = function () &#123;&#125;;// 观察者包含一个notify(通知)的回调方法Observer.prototype.notify = function (info) &#123; // 在该方法内做出操作 console.log(`观察者发现 $&#123;info&#125; 出现更改`);&#125;; Subject 被观察者123456789101112131415161718192021222324252627282930313233343536var Subject = function (info) &#123; // 注册自己（被观察者）的信息 this.info = info; // 已经注册的观察者的列表 this.observerList = [];&#125;;Subject.prototype = &#123; // 注册一个监视当前对象的观察者到观察者列表 register: function (observer) &#123; this.observerList.push(observer); &#125;, // 不在关注当前对象的观察者，注销观察者对象 remove: function (observer) &#123; // 获得当前观察者列表的长度 var listLength = this.observerList.length; for (var i = 0; i &lt; listLength; i++) &#123; if ((observer = this.observerList[i])) &#123; // 从观测者列表删除该观察者 this.observerList.splice(i, 1); return true; &#125; &#125; return false; &#125;, // 通知所有注册的观察者对象 update: function () &#123; var observer; // 获得当前观察者列表的长度 var listLength = this.observerList.length; for (var i = 0; i &lt; listLength; i++) &#123; observer = this.observerList[i]; // 调用Observer对象的notify回调方法 observer.notify(this.info); &#125; &#125;,&#125;; 小结 以上便是Observer模式的代码实现雏形，主要的流程和逻辑已经包括在其中了。但是在具体实现的时候，可以做出部分的调整。 比如： 1observer.notify(this.info); 这一句代码可以不一定要传输对象自身的所有信息，放在出版社那，可能只需要传入一个新发布的书名。 那么接下来，我们按照之前的出版社-书店-读者的例子，进行一个具体实例的代码实现。 具体实例的代码实现Observer 观察者(书店) 定义123456var BookStore = function () &#123;&#125;;// 书店包含一个notify(通知)的回调方法BookStore.prototype.notify = function (CompanyName,BookName) &#123; // 在该方法内做出操作 console.log(`读者快来，我这出了新书：$&#123;CompanyName&#125; 发版的 $&#123;BookName&#125;`);&#125;; Subject 被观察者(出版社) 定义12345678910111213141516171819202122232425262728293031323334353637383940var Company = function (CompanyName) &#123; // 出版社名称 this.Name = CompanyName; // 新的书名 this.NewBookName = \"\"; // 已经注册的书店的列表 this.bookStoreList = [];&#125;;Company.prototype = &#123; // 注册一个监视当前对象的书店到书店列表 register: function (bookStore) &#123; this.bookStoreList.push(bookStore); &#125;, // 不在关注当前对象的书店，注销书店对象 remove: function (bookStore) &#123; // 获得当前书店列表的长度 var listLength = this.bookStoreList.length; for (var i = 0; i &lt; listLength; i++) &#123; if ((bookStore == this.observerList[i])) &#123; // 从书店列表删除该观察者 this.bookStoreList.splice(i, 1); return true; &#125; &#125; return false; &#125;, // 通知所有注册的书店对象 publish: function (BookName) &#123; // 记录新发布书的名字 this.NewBookName = BookName; var bookStore; // 获得当前书店列表的长度 var listLength = this.bookStoreList.length; for (var i = 0; i &lt; listLength; i++) &#123; bookStore = this.bookStoreList[i]; // 调用BookStore对象的notify回调方法 bookStore.notify(this.Name,this.NewBookName); &#125; &#125;,&#125;; 具体使用12345678910111213141516171819202122232425262728293031// 初始化一个出版社——VicoHu出版社var company = new Company(\"VicoHu出版社\");// 初始化三家商店var bookStore1 = new BookStore(\"小胡书店\");var bookStore2 = new BookStore(\"二刘书店\");var bookStore3 = new BookStore(\"大黄书店\");// 重写bookStore3的notify方法实现发布新书时的不同操作bookStore3.notify = function (CompanyName, BookName) &#123; // 在该方法内做出操作 console.log( `$&#123;this.Name&#125;促销，新书上架：$&#123;CompanyName&#125; 发版的 $&#123;BookName&#125;，比其他的店都要便宜很多。` );&#125;;// 将三家商店注册到出版社的商店列表里company.register(bookStore1);company.register(bookStore2);company.register(bookStore3);// 发布新书company.publish(\"《挪威的森林》\");// 控制台输出如下内容/** * 小胡书店有促销活动!!!!! 读者快来，我这出了新书：VicoHu出版社 发版的 《挪威的森林》 * 二刘书店有促销活动!!!!! 读者快来，我这出了新书：VicoHu出版社 发版的 《挪威的森林》 * 大黄书店促销，新书上架：VicoHu出版社 发版的 《挪威的森林》，比其他的店都要便宜很多。 */ 小结在上面的具体实例的代码实现中，我们完成了书店的创建，和出版社的创建，并且将多个商店注册到出版社，并在出版社发布新书的时候，通知给所有的商店，让商店发出广告和通知给我们（读者）。其实，从本质上而言，商店（观察者）是被动的，它需要依赖于出版社（被观察者）调用notify方法，来完成商店的广告发布。但是，商店的广告的发布，可以通过重写 notify 方法来进行自定义的操作。 总结Observer 设计模式的优点和缺点都比较明显。 Observer模式 优点 解耦。这是现在大多数的设计模式都在做的一件事情，例如：MVC、MVVM等。其好处就在于，不需要在设计观察者的时候，关注被观察者的设计。这样可以只需要关注一个notify方法的参数。这样的好处很明显，可以把更多的注意力放在设计某个对象的上面。 广播通讯。如我们后面发布的 《挪威的森林》一书，只需要调用一出版社的publish方法，就可以对所有已经在出版社注册的商店进行通知。 Observer模式 缺点 观察者过于被动。观察者在这个设计中，其实更像是个被通知的身份，它没有主动了解被观察者的能力。只能根据观察者给的信息，做出反应和操作。 抗风险性不高。假如某个注册的商店的方法出现问题，或者一直未执行完，会影响到后面的商店的通知。从而影响整体广播的执行。 最后的总结 这世界上没有绝对通用的设计模式，都是根据任务的需求，选择合适的设计模式。但是，倘若你连某个合适的设计模式都不知道，就会错过一些事半功倍的机会。所以，只有不断的去学习，不断走出舒适圈，才能让自己走的更远，并成为一个编码更加高效、稳定的开发者。加油吧！各位！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.vicohu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript","slug":"设计模式/JavaScript","permalink":"https://www.vicohu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/JavaScript/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.vicohu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.vicohu.com/tags/JavaScript/"}]},{"title":"Vue中v-for配合key使用的重要性","slug":"Vue中v-for配合key使用的重要性","date":"2020-07-12T15:15:21.000Z","updated":"2020-09-05T11:25:14.056Z","comments":true,"path":"Vue中v-for配合key使用的重要性/","link":"","permalink":"https://www.vicohu.com/Vue%E4%B8%ADv-for%E9%85%8D%E5%90%88key%E4%BD%BF%E7%94%A8%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/","excerpt":"","text":"在 Vue 官网的风格指南中，有很多对于Vue编码的风格的要求和建议。在这里，主要解释在编码指南中，为优先级A：必要的 的编码规范的","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.vicohu.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.vicohu.com/tags/Vue/"}]},{"title":"Vue中v-if和v-show的区别和使用场景","slug":"Vue中v-if和v-show的区别和使用场景","date":"2020-07-05T10:19:21.000Z","updated":"2020-09-05T11:25:14.056Z","comments":true,"path":"Vue中v-if和v-show的区别和使用场景/","link":"","permalink":"https://www.vicohu.com/Vue%E4%B8%ADv-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"我们在学习Vue的时候，肯定产生过对 v-if 和 v-show 的区别存在疑惑。在不深入到渲染逻辑的情况下，大到时候，给开发者的直观感受都是一样的：显示和不显示。但在实现的本质上，是有差别的。 其实在Vue的官方文档中，也有做出一些相应的解释。 概念和区别官方文档概念v-if v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。1 v-show v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。 区别根据以上的官方文档，其实就已经表明出了其背后的渲染逻辑。 v-if 是根据表达式返回的值，来判断是否渲染，更准确的说是，假如表达式返回值为 false，则直接跳过该元素及其子元素的渲染，根本不消耗资源去生成相应的 Virtual DOM。换句话说，v-if 的表达式返回值，会直接触发到 当前组件 生命周期，并且事件监听器和子组件会被适当地被销毁和重建。所以，可以理解为 v-if 是惰性的，他不会在页面初始化时，被无条件渲染，而是按需响应式地渲染。 而 v-show ，这是无论表达式返回值是否是 true 都会在 create 生命周期，无条件消耗资源生成对应的 Virtual DOM，并挂载到HTML页面中，只是再根据表达式返回值，切换 display 这个 CSS 属性。 使用场景从页面显示上看，二者并没有太多的区别，基本上就是显示和不显示的用户体验差别。在需要频繁切换显示状态的组件或者相对渲染强度大但是过分依赖生命周期或的组件，更加适合用 v-show 作为切换的指令。因为，v-if 会带来实时渲染所带来的不必要的资源消耗，和操作延迟，这给用户的体验并不是很好，相对下，v-show基于CSS的显示与隐藏，更加快捷，响应速度更快，并且资源消耗也会更小。但 v-show 的弱点也很明显，因为页面是在页面初始化的时候，就得完成全部的渲染，这使得页面的加载会更消耗资源，也意味着页面加载时长会相应增长。假如组件对资源的消耗，已经影响到了用户的体验，可能采取 v-if 将组件分成小块，按需加载或许会更加有用户体验。 总而言之，v-if 是在表达式返回值切换时，才渲染和摧毁组件及其子组件，他会触发组件的生命周期。而 v-show 是在页面初始化时就进行了完整的渲染，这会在某些情况下，明显增加页面的加载时间。具体的使用，还得根据需求、页面的加载时长以及组件的渲染强度，进行合适的选择。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.vicohu.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.vicohu.com/tags/Vue/"}]},{"title":".Net Core3.1 WebAPI CORS跨域配置——踩坑","slug":"net core3.1 CORS跨域配置——踩坑","date":"2020-06-23T09:35:42.000Z","updated":"2020-09-05T11:25:14.057Z","comments":true,"path":"net core3.1 CORS跨域配置——踩坑/","link":"","permalink":"https://www.vicohu.com/net%20core3.1%20CORS%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E8%B8%A9%E5%9D%91/","excerpt":"","text":"之前在用Vue开发的过程中，使用到了.Net Core 3.1 的 WebAPI，然后必然要解决一个 CORS 跨域的问题。根据百度，学习到了配置配置跨域的方法。一运行项目访问接口，就直接在Startup类中直接报错 报错异常如下图1234System.InvalidOperationException HResult&#x3D;0x80131509 Message&#x3D;The CORS protocol does not allow specifying a wildcard (any) origin and credentials at the same time. Configure the CORS policy by listing individual origins if credentials needs to be supported. Source&#x3D;Microsoft.AspNetCore.Cors 其实解决方案也很简单： 在Startup类的ConfigureServices方法中添加如下代码：1234567891011&#x2F;&#x2F;添加cors 服务 配置跨域处理 services.AddCors(options &#x3D;&gt;&#123; options.AddPolicy(&quot;any&quot;, builder &#x3D;&gt; &#123; builder.WithMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;HEAD&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;) &#x2F;&#x2F;.AllowCredentials()&#x2F;&#x2F;指定处理cookie .AllowAnyOrigin(); &#x2F;&#x2F;允许任何来源的主机访问 &#125;);&#125;); 在Startup类的Configure方法中添加如下代码：12app.UseCors(&quot;any&quot;);&#x2F;&#x2F; 注意，这一行代码一定要写在 app.UseAuthorization(); 的下面，否则会报错的。 以上就是 .Net Core3.1 CORS跨域配置的解决方案。","categories":[{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/categories/C/"},{"name":".Net","slug":"C/Net","permalink":"https://www.vicohu.com/categories/C/Net/"},{"name":".Net Core3.1","slug":"C/Net/Net-Core3-1","permalink":"https://www.vicohu.com/categories/C/Net/Net-Core3-1/"}],"tags":[{"name":"WebAPI","slug":"WebAPI","permalink":"https://www.vicohu.com/tags/WebAPI/"},{"name":".Net Core3.1","slug":"Net-Core3-1","permalink":"https://www.vicohu.com/tags/Net-Core3-1/"}]},{"title":".gitignore 无效的解决方案","slug":"gitignore 无效的解决方案","date":"2020-06-21T07:30:26.000Z","updated":"2020-09-05T11:25:14.056Z","comments":true,"path":"gitignore 无效的解决方案/","link":"","permalink":"https://www.vicohu.com/gitignore%20%E6%97%A0%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"我们在使用git的时候，经常会使用.gitignore文件，定义规则，对项目文件进行上传筛选但在某些时候，我们可能会出现在项目已经创建，或者项目的中途，创建该文件，而导致的改文件无法生效的情况。 这是因为 .gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。我们可以尝试用清除本地缓存的方法，解决该问题。 1234git rm -r --cached .git add .git commit -m &quot;update .gitignore&quot;git push -u origin master","categories":[{"name":"Git","slug":"Git","permalink":"https://www.vicohu.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.vicohu.com/tags/Git/"}]},{"title":"C# .Net CodeFist编码基础流程","slug":"CSharp .Net CodeFist编码基础流程","date":"2020-06-17T10:20:21.000Z","updated":"2020-09-05T11:25:14.055Z","comments":true,"path":"CSharp .Net CodeFist编码基础流程/","link":"","permalink":"https://www.vicohu.com/CSharp%20.Net%20CodeFist%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/","excerpt":"","text":"Code First 基础流程 1. 定义好实体类（对应数据库的表及其字段） 2. 定义好上下文操作类（以context结尾） 12345678910&#x2F;&#x2F;在该项目上右键找到“管理 NuGet程序包” 搜索EntityFrameWork并下载好public nCovContext() : base(&quot;name&#x3D;aa&quot;) &#x2F;&#x2F; 声明连接字符串&#123;&#125;&#x2F;&#x2F; 注册实体类 public DbSet&lt;tbStudent&gt; tbStudent &#123; get; set; &#125;public DbSet&lt;tbTeacher&gt; tbTeacher &#123; get; set; &#125;public DbSet&lt;tbDetail&gt; tbDetail &#123; get; set; &#125; 3. 在App.config里加上数据库连接字符串 123&lt;connectionStrings&gt; &lt;add name&#x3D;&quot;aa&quot; connectionString&#x3D;&quot;server&#x3D;.;database&#x3D;nCov3804DB;uid&#x3D;sa;pwd&#x3D;123456&quot; providerName&#x3D;&quot;System.Data.SqlClient&quot; &#x2F;&gt;&lt;&#x2F;connectionStrings&gt; 【注意: 上下文操作类的构造方法的name=”aa”要与App.config的name=aa保持一致】 Code First模式默认的约定 主键约定： 以ID或者是类型ID的字段会自动生成为主键。如果是Int类型，会默认为自增 表名约定：跟类名一样，会默认加上一个s 一对多的约定：导航属性。 字符串约定：string =&gt; nvarchar(Max),默认允许为空","categories":[{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/categories/C/"},{"name":".Net","slug":"C/Net","permalink":"https://www.vicohu.com/categories/C/Net/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/tags/C/"},{"name":".Net","slug":"Net","permalink":"https://www.vicohu.com/tags/Net/"}]},{"title":"LeetCode——打家劫舍问题——动态规划","slug":"LeetCode——打家劫舍问题——动态规划","date":"2020-05-27T13:27:27.000Z","updated":"2020-09-05T11:25:14.056Z","comments":true,"path":"LeetCode——打家劫舍问题——动态规划/","link":"","permalink":"https://www.vicohu.com/LeetCode%E2%80%94%E2%80%94%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"打家劫舍问题你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 2: 1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。 偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。 对于求最优解得题目，我编码效率最快的，自然是递归，但是，递归在数组的长度越来越长是，所需的世界也会飞速增长。因为递归进行了很多重复的运算。对于本题而言，或许动态规划更加适合当前题目的情景。根据题目规则我们可以得到几个信息。 Opt[i] = （ Opt[i - 2] + Nums[i] ） 或者 （Opt[i - 1]） i为第i个元素，opt[i]为第i个及其之前的元素的最优解（不考虑之后的元素，只考虑当前元素和之前的元素），Nums为传入的数组 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int rob(int[] nums) &#123; int y = 0, n = 0; // 初始化2个变量，代表着选取该节点和不选取该节点。y: yes, n: no int[] opt = new int[nums.length]; // 初始化一个数组，用于存储每个节点的当前元素及其之前元素的最优解（不管之后的元素 是否选择） if (nums.length == 0) &#123; // 如果传入的数组为空，返回值为0 return 0; &#125; if (nums.length == 1) &#123; // 如果传入的值为1，返回值为当前数组的唯一元素 return nums[0]; &#125; // 如果，满足传入数组的长度大于等于2 opt[0] = nums[0]; opt[1] = Math.max(nums[0],nums[1]); // 第一个元素及之前元素的最优解为第一个元素本身 // 第二个元素及之前元素的最优解为第一个元素或者第二个元素（取大值） for(int i = 2;i &lt;= nums.length - 1; i++ ) &#123; // 循环计算，2和2之后每一个元素及之前元素的最优解 // 每个节点都会遇到2个可能，需要当前元素和不需要当前元素 y = nums[i] + opt[i - 2]; n = opt[i - 1]; opt[i] = Math.max(y,n); // 取最优解 &#125; Arrays.sort(opt); // 对最优解进行排序，取最大值即为当前题目的最优解 return opt[nums.length - 1]; // 返回排序后最后一个元素（最大的元素） &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"Java","slug":"算法/LeetCode/Java","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/Java/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.vicohu.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"https://www.vicohu.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://www.vicohu.com/tags/Java/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.vicohu.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode——会议室 II——动态规划","slug":"LeetCode——会议室 II——动态规划","date":"2020-05-26T07:51:22.000Z","updated":"2020-09-05T11:25:14.055Z","comments":true,"path":"LeetCode——会议室 II——动态规划/","link":"","permalink":"https://www.vicohu.com/LeetCode%E2%80%94%E2%80%94%E4%BC%9A%E8%AE%AE%E5%AE%A4%20II%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"会议室 II给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si &lt; ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。 示例 1: 12输入: [[0, 30],[5, 10],[15, 20]]输出: 2 示例 2: 12输入: [[7,10],[2,4]]输出: 1 这个题目有点类似于上下车问题。本题是规划的对于时间冲突的解决方案。根据题目，我们发现，并不需要在意该会议持续时间。因为会议时间已经固定了，所以我们只需要关注会议室及其会议结束时间即可。因为只有会议时间结束，才能进行下一个会议。否则，这需要开一个新的会议室，去进行会议。为了最优开会成本和时间效率，下一个会议进入的房间，根据会议室结束时间和该会议开始时间的差决定，时间差越小，开会越能“无缝连接”，于是效率越高。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public int minMeetingRooms(int[][] intervals) &#123; if(intervals == null || intervals.length ==0) return 0; // 根据会议开始时间，数组的重新排序（开始时间的从小到大） Arrays.sort(intervals,new Comparator&lt;&gt;()&#123; @Override public int compare(int[] o1, int[] o2) &#123; return o1[0]-o2[0]; &#125; &#125;); // 定义一个HashMap记录会议室及其结束时间 Map&lt;Integer,Integer&gt; RoomTime = new HashMap&lt;&gt;(); // 第一个开始会议的已经毋庸置疑，就是开会时间最早的那个会议，也就是排序后的第一个会议 RoomTime.put(1,intervals[0][1]); // 定义一个表示符号，用于后面的forEach跳过第一个会议，因为第一个会议已经安排好了 boolean isFirst = false; for(int[] item :intervals)&#123; if(!isFirst) &#123; // 跳过第一个会议，因为已经安排了 isFirst = !isFirst; continue; &#125; // 时间差 int fix = 0; // 该会议，目前临时安排的房间 int tempRoom = 0; // 循环所有会议室 for(Map.Entry&lt;Integer,Integer&gt; entry: RoomTime.entrySet())&#123; // 如果时间上满足要求 if(entry.getValue() &lt;= item[0]) &#123; // 取最优的会议室给当前会议 if(fix == 0 || item[0] - entry.getValue() &lt;= fix) &#123; fix = item[0] - entry.getValue(); tempRoom = entry.getKey(); &#125; &#125; &#125; // 如果临时间号不为0，则有房间满足要求。否则，说明没有房间满足要求，需要开一个新的会议室，安排该会议 if(tempRoom != 0) RoomTime.put(tempRoom, item[1]); else RoomTime.put(RoomTime.size() + 1,item[1]); &#125; // 最后返回房间的数量，即是本题的答案 return RoomTime.size(); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"Java","slug":"算法/LeetCode/Java","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/Java/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.vicohu.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"https://www.vicohu.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://www.vicohu.com/tags/Java/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.vicohu.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"教你如何快速刷网课","slug":"教你如何快速刷网课","date":"2020-05-22T10:20:21.000Z","updated":"2020-09-09T11:59:31.430Z","comments":true,"path":"教你如何快速刷网课/","link":"","permalink":"https://www.vicohu.com/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%B7%E7%BD%91%E8%AF%BE/","excerpt":"","text":"这段时间，疫情之下，直播课、网课，得到了空前的发展和壮大。并且应运出很多奇葩的课程，“大学生体育”，里面教你怎么打篮球，怎么打羽毛球，然而，却根本没人可以在家中完成以上联系。“体育”竟然变成了一种偏理论的课程，并且长达十几个小时。实在诙谐。 于是，在朋友的介绍下，我得知了一个惊天地泣鬼神的快速刷完网课的方式——“代刷网课“. 代刷网课“代刷网课”这个产业，在疫情期间，得到了越多人的认可。因为他可以为学生节省很多的时间，去完成一些他们愿意做的事情，比如我放弃了奇葩的”大学生体育”，学习Vue3和Nuxt.js，这十几个小时，可以完成太多的事情。而请”代刷“的成本，却不过2-3元不等，何乐而不为呢？ 我相信大多数人都明白，有些课程的意义是真的对于不感兴趣的人而言，是没有价值的。只会增加大学的心理负担。而刷网课，虽然表面不光鲜亮丽，但却是一种很好的方式，去节省我们大学期间宝贵的时间。我们可以拿着十几到几十小时不等的时间，去学习自己喜欢的事情，或者和室友朋友花这时间去聊天、娱乐毕竟大学不仅是学习专业知识，更多的是锻炼人际交往的能力。这是进入社会必会的技能。 怎样代刷网课在我的朋友的介绍下，我得知一个专业刷网课的平台，这个刷网课平台是他和几个计算机软件技术专业的朋友，共同搭建和完成的，并且在运营发现月收益可以大于月成本后，他们便一直在维护这个网站的运行，并维护着刷网课脚本的功能。运行至今也有3年的时间了。 刷网课平台地址：点击进入，VicoHu刷网课平台 点击上面链接，进入刷网课平台 你会看到到如下页面： VicoHu网课刷网课平台 然后，我们点击蓝色按钮的提交课程 VicoHu网课刷网课平台 至于选择点击哪一个，则需要依照你需要刷的网课的平台来，例如：超星学习通、智慧树/知到，这些均在爆单网课平台中。 我们拿超星学习通为例，进入后选择学习通/超星，并填写相关信息，和下单数量（一科一份，多科多份） VicoHu网课刷网课平台 然后点击查询课程，会弹出一个提示框，我们点击确定按钮 VicoHu网课刷网课平台 点击上图确定后，耐心等待片刻，会再次弹出一个框，勾选要刷的网课，再“确认选择”，然后点击“立刻购买”即可。 VicoHu网课刷网课平台 然后，便根据下方的提示，不要在手机或电脑上频繁登录账号，一般网课根据时长1-3天不等，便可以刷完。 在选择商品时，可以看到有“代刷”，“高质量代刷”和”秒刷 超级速“， 3种类别，”代刷“就是最普通的刷网课，速度中等一般2-3天刷完，相对比较稳定。“高质量代刷”。是销量最好的，也是老用户最喜欢的刷课选项，速度1-2天左右刷完，速度相对较快，极其稳定，上线至今0失误。”秒刷 超级速“这款是针对网课快要截止的用户，可以在几小时到半天时间内刷完网课，速度极快。 为什么要代刷网课，为什么出现代刷网课（我的一点思考和见解）本质上，学生想刷网课嘛？其实是不想的，他们心里会背负一种内疚感。如果你里面放的是他们想要的东西，感兴趣的东西，或者是真的对未来有可见价值的东西，我相信绝大部分人都不会拒绝。代刷网课只是一种节省掉低效时间、低价值时间的工具。工具本身又怎么会有错呢。 代刷网课，在我朋友那是副业，在大学生那是工具，而对于我而言是一种新的思考。 思考为什么网课里会出现这样没有什么价值的课程，却依旧有着和其他重要的课程一样的学分？思考为什么我们喊着反对应试教育，要因材施教的情况下，却依旧在网课这没有改善。 我们中国的大学教育者是不是该反思，而不是抱着一种，只要学生看完了，自己任务就完成的心态，去教育学生。而应该更多的去思考，怎么让把一个可能学生不兴趣但一定有价值的课程，变得有趣，变得更有价值，变得让学生更容易接受。我相信，教育的方向绝对不是说让大学生依靠自己的“自觉”去学习。这不过是大学教师给自己台阶，给自己不认真备课的借口。 我承认教育者，有他的辛苦之处，可是哪个行业不辛苦呢？我们软件工程师经常的996，却很多时候拿着和大学的老师有着差不多的工资。但我们会说不加班了吗？不会，因为我们知道，我们不996就意味着，我们丢失了工作，意味着我们不知道下一顿饭在哪。 我们都应该，为自己的职位的职责付出应该的努力。同样，大学生也该为自己省略那些观看对于自己低价值课程的时间。去做自己喜欢的事情，去做有价值的事情，去做那个追逐自己内心的自己。","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://www.vicohu.com/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"刷网课","slug":"刷网课","permalink":"https://www.vicohu.com/tags/%E5%88%B7%E7%BD%91%E8%AF%BE/"},{"name":"大学生刷网课","slug":"大学生刷网课","permalink":"https://www.vicohu.com/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%88%B7%E7%BD%91%E8%AF%BE/"}]}],"categories":[{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/categories/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.vicohu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript","slug":"设计模式/JavaScript","permalink":"https://www.vicohu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://www.vicohu.com/categories/Vue/"},{"name":".Net","slug":"C/Net","permalink":"https://www.vicohu.com/categories/C/Net/"},{"name":".Net Core3.1","slug":"C/Net/Net-Core3-1","permalink":"https://www.vicohu.com/categories/C/Net/Net-Core3-1/"},{"name":"Git","slug":"Git","permalink":"https://www.vicohu.com/categories/Git/"},{"name":"算法","slug":"算法","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"Java","slug":"算法/LeetCode/Java","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/Java/"},{"name":"小技巧","slug":"小技巧","permalink":"https://www.vicohu.com/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.vicohu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.vicohu.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://www.vicohu.com/tags/Vue/"},{"name":"WebAPI","slug":"WebAPI","permalink":"https://www.vicohu.com/tags/WebAPI/"},{"name":".Net Core3.1","slug":"Net-Core3-1","permalink":"https://www.vicohu.com/tags/Net-Core3-1/"},{"name":"Git","slug":"Git","permalink":"https://www.vicohu.com/tags/Git/"},{"name":".Net","slug":"Net","permalink":"https://www.vicohu.com/tags/Net/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.vicohu.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"https://www.vicohu.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://www.vicohu.com/tags/Java/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.vicohu.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"刷网课","slug":"刷网课","permalink":"https://www.vicohu.com/tags/%E5%88%B7%E7%BD%91%E8%AF%BE/"},{"name":"大学生刷网课","slug":"大学生刷网课","permalink":"https://www.vicohu.com/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%88%B7%E7%BD%91%E8%AF%BE/"}]}