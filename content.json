{"meta":{"title":"VicoHu-个人博客","subtitle":"用程序员的眼光，戏剧地看待世界","description":"VicoHu，一个有导演梦的程序员","author":"VicoHu","url":"https://www.vicohu.com","root":"/"},"pages":[{"title":"categories","date":"2020-05-22T08:07:37.000Z","updated":"2020-09-05T11:25:14.057Z","comments":false,"path":"categories/index.html","permalink":"https://www.vicohu.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-05-22T08:06:21.000Z","updated":"2020-09-05T11:25:14.058Z","comments":false,"path":"tags/index.html","permalink":"https://www.vicohu.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java多线程编程","slug":"Java多线程编程","date":"2020-10-12T06:25:35.000Z","updated":"2020-11-23T06:45:42.565Z","comments":true,"path":"Java多线程编程/","link":"","permalink":"https://www.vicohu.com/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/","excerpt":"","text":"一、进程和线程进程和线程分别是什么？ 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。线程是程序中一个单一的顺序控制流程。进程内一个相对独立的、可调度的执行单元，是系统独立调度和分派CPU的基本单位指运行中的程序的调度单位。在单个程序中同时运行多个线程完成不同的工作，称为多线程。 进程与线程的区别 进程是资源分配的最小单位，线程是程序执行的最小单位。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多，线程的上下文切换的性能消耗要小于进程。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 进程与线程的关系如下图所示，一个程序可以由多个进程组成，每一个进程又可以有一个或者多个线程。 二、同步与异步对于一次方法的调用来说，同步方法调用一旦开始，就必须等待该方法的调用返回，后续的方法才可以继续执行。 异步的话，方法调用一旦开始，就可以立即返回，调用者可以执行后续的方法，这里的异步方法通常会在另一个线程里真实的执行，而不会妨碍当前线程的执行。 三、并行与并发在异步任务出现后，并行与并发这个词汇越来越多的出现在我们的视野中。 共同点： 都可以表示在同一时间范围内有两个或多个任务同时在执行 不同点 任务调度的时候还是有区别。当多个任务在执行的时候，并发是没有时间上的重叠的，多个任务是交替执行的，由于切换的非常快，对于外界调用者来说相当于同一时刻多个任务一起执行了；而并行可以看到时间上是由重叠的，也就是说并行才是真正意义上的同一时刻可以有多个任务同时执行。 并发任务执行过程： 并行任务执行过程： 四、Java实现多线程的方式 实现Runnable接口 12345678910111213public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(\"123\"); &#125; public static void main(String[] args) &#123; MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable, \"t1\"); thread.start(); &#125;&#125; 继承Thread，重写run方法 注意事项： 启动线程的是start方法而不是run方法，如果用run方法，那么他就是一个普通的方法执行了。 Thread类本身实现了Runnable接口，并且持有run方法，但Thread类的run方法主体是空的，Thread类的run方法通常是由子类的run方法重写。 1234567891011121314public class MyThread extends Thread &#123; @Override public void run() &#123; while (true) &#123; System.out.println(this.currentThread().getName()); &#125; &#125; public static void main(String[] args) &#123; MyThread thread = new MyThread(); thread.start(); //线程启动的正确方式 &#125;&#125; 使用 Callable 和 Future 创建线程 1234567891011121314151617181920212223static void callable() &#123; Callable&lt;String&gt; callable = new Callable&lt;String&gt;() &#123; @Override public String call() &#123; try &#123; Thread.sleep(1500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return \"Done!\"; &#125; &#125;; ExecutorService executor = Executors.newCachedThreadPool(); Future&lt;String&gt; future = executor.submit(callable); try &#123; String result = future.get(); //get是一个阻塞方法，虽然你换了个线程，但是你取数据的时候还是会卡住 System.out.println(\"result: \" + result); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; feature.get() 是一个阻塞方法，那么有没有办法不卡住线程呢？ 答案是有的，那就是循环去查： 1234567891011Future&lt;String&gt; future = executor.submit(callable);try &#123; while(!future.isDone)&#123; //检查是否已经完成，如果否，那么可以让主线程去做其他操作，不会被阻塞 &#125; String result = future.get(); //get是一个阻塞方法，虽然你换了个线程，但是你取数据的时候还是会卡住 System.out.println(\"result: \" + result);&#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace();&#125; Executors JDK 1.5 后引入的 Executor 框架的最大优点是把任务的提交和执行解耦。通过 Executors 的工具类可以创建以下类型的线程池： 下面介绍常用的两种线程池。 FixThreadPool：固定大小线程池 创建固定大小的线程池。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。适用于集中处理多个任务。 如果现在我需要优先处理一下图片，但是处理完就释放掉这些线程，那么代码可以这么写。 123456789101112ExecutorService imageProcessor = Executor.newFixedThreadPool(); //我需要你马上给我很多个线程，然后一旦用完我就不要了List&lt;Image&gt; images; //图片集合for(Image image : images)&#123; //处理图片 improcessor.excutor(iamgeRunnable,image);&#125;//等图片处理完成后终止线程imageProcessor.shutdown(); cacheThreadPool：缓存线程池 当提交任务速度高于线程池中任务处理速度时，缓存线程池会不断地创建线程，适用于提交短期的异步小程序，以及负载较轻的服务器。 1234567891011121314static void executor() &#123; Runnable runnable = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Thread with Runnable started!\"); &#125; &#125;; Executor executor = Executors.newCachedThreadPool(); executor.execute(runnable); executor.execute(runnable); executor.execute(runnable);&#125; Executor 接口里面有两个重要的方法，一个是 shutdown，一个是 shutdownNow。 它们两个的区别是：shutdown 不再允许扔新的 runnable 进来。shutdownNow 不只是新的不允许，就算是正在执行的任务也不允许再继续执行。 五、线程安全线程安全概念：当多个线程访问某一个类（对象或方法）时，这个类始终能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。 JVM内存模型特点： Java 所有变量都存储在主内存中。 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量副本。 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接在主内存读写。 不同线程之间无法访问其他线程内存中的变量，线程间变量值的传递需要通过主内存来完成。线程 1 对共享变量的修改，要想被线程 2 及时看到，必须经过如下 2 个过程： 把工作内存 1 中更新过的共享变量刷新到主内存中。 将主内存中最新的共享变量的值更新到工作内存 2 中。 Synchronized的使用synchronized 可以保证在同一时刻只有一个线程执行被 synchronized 修饰的方法/代码，即保证操作的原子性和可见性。 具体的使用可见博客另一片博文《Java中Synchonized的答疑》","categories":[{"name":"Java","slug":"Java","permalink":"https://www.vicohu.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.vicohu.com/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://www.vicohu.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Java中Synchronized的答疑","slug":"Java中Synchronized的答疑","date":"2020-09-27T08:20:15.000Z","updated":"2020-11-23T06:42:04.708Z","comments":true,"path":"Java中Synchronized的答疑/","link":"","permalink":"https://www.vicohu.com/Java%E4%B8%ADSynchronized%E7%9A%84%E7%AD%94%E7%96%91/","excerpt":"","text":"什么场景下需要使用Synchronized？在多线程编程中，当多个线程在使用同一个共享资源的时候时候，并可能对共享资源进行修改的时候，需要使用到Synchronized。 如下图所示： 为什么要使用Synchronized？多个线程对同一个资源进行读取和修改，可能会导致脏读，而导致修改结果与预期不一致，因为该线程读取（复制）到的值，并非共享资源当前真实的值，因为其他线程此刻可能已经对该共享资源进行了修改。 因此，需要使用锁来对共享资源进行锁定，确保所有的线程在当前线程对数据修改完成前，其他线程都处于等待修改状态，而避免脏读导致的与预期不一致的情况。 synchronized 的作用范围？ 在静态方法上加锁。 在非静态方法上加锁。 在代码块上加锁。 123456789101112131415161718192021public class SynchronizedSample &#123; private final Object lock = new Object(); private static int money = 0; //非静态方法 public synchronized void noStaticMethod()&#123; money++; &#125; //静态方法 public static synchronized void staticMethod()&#123; money++; &#125; public void codeBlock()&#123; //代码块 synchronized (lock)&#123; money++; &#125; &#125; &#125; Synchronized 三种作用范围的加锁方式的区别?首先，锁是加在对象上的，我们是在对象上加锁。这也就是为什么wait方法和notify方法需要先锁定对象，才能执行。因为必须要先有锁，才能释放锁。 作用范围 锁住的对象 静态方法 当前类实例对象（this） 非静态方法 当前类对象 代码块 指定的对象（ Synchronized(指定对象) ） JVM 是怎么通过 synchronized 在对象上实现加锁，保证多线程访问竞态资源安全的？在 JDK6 以前，synchronized 那时还属于重量级锁。每次加锁都依赖操作系统 Mutex Lock (互斥锁)实现，涉及到操作系统让线程从用户态切换到内核态，切换成本很高。 到了 JDK6，研究人员引入了偏向锁和轻量级锁。 synchronized 是公平锁还是非公平锁？非公平锁。主要有以下二点原因： Synchronized 在线程竞争锁时，首先做的不是直接进 ContentionList 队列排队，而是尝试自旋获取锁（可能 ContentionList 有别的线程在等锁），如果获取不到才进入 ContentionList，这明显对于已经进入队列的线程是不公平的。 另一个不公平的是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。","categories":[{"name":"Java","slug":"Java","permalink":"https://www.vicohu.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.vicohu.com/tags/Java/"}]},{"title":"C# 索引器","slug":"CSharp 索引器 ","date":"2020-08-23T09:20:45.000Z","updated":"2020-09-09T12:11:11.423Z","comments":true,"path":"CSharp 索引器 /","link":"","permalink":"https://www.vicohu.com/CSharp%20%E7%B4%A2%E5%BC%95%E5%99%A8%20/","excerpt":"","text":"索引器的定义 索引器允许类或结构的实例就像数组一样进行索引。 无需显式指定类型或实例成员，即可设置或检索索引值。 索引器类似于属性，不同之处在于它们的访问器需要使用参数。 索引器的使用场景 不知道各位是否有遇到过这样一种情况，我们基于一个类或继承于同一个父类或接口的类，实例化多个对象，却无法进行统一的管理和定义。即使是利用 List 进行管理，依旧有很多不方便和局限的地方。 索引器的出现，就是为了解决这个问题，它允许类或结构的实例就像数组一样进行索引。 索引器的 C# 实现简单例子定义索引器12345678910111213141516// 定一个索引器SimpleCollectionpublic class SimpleCollection&lt;T&gt;&#123; // 定一个数组，转载这些传入的数据 private T[] arr = new T[100]; // 定义一个属性，用于获取数组的长度 public int Length =&gt; arr.Length; // 定义一个索引器，允许使用[]对数据进行索引 public T this[int i] &#123; get =&gt; arr[i]; set =&gt; arr[i] = value; &#125;&#125; 定义一个需要使用索引器的类123456789// 定义一个Car类public class Car&#123; public string name; public Car(string name) &#123; this.name = name; &#125;&#125; 索引器的使用12345678910111213141516171819202122public static void Main(string[] args)&#123; SimpleCollection&lt;Car&gt; simple = new SimpleCollection&lt;Car&gt;(); simple[0] = new Car(\"Car\"); simple[1] = new Car(\"Car1\"); simple[2] = new Car(\"Car2\"); simple[3] = new Car(\"Car3\"); simple[4] = new Car(\"Car4\"); for (int i = 0; i &lt; simple.Length; i++) &#123; Console.WriteLine(simple[i].name); &#125;&#125;/*输出以下内容：CarCar1Car2Car3Car4*/ 索引器实际使用 在更多的时候，我们不会像上面的实例一样去写索引器。更多的时候，是索引器的定义内，加入一些对数据进行处理的方法。 例如上面的例子，我们希望可以讲输出car属性的方法，内置在索引器内。 定义新的索引器123456789101112131415161718192021222324252627// 定一个索引器SimpleCollectionpublic class SimpleCollection&lt;T&gt; where T:Car&#123; // 定一个数组，转载这些传入的数据 private T[] arr = new T[100]; // 定义一个属性，用于获取数组的长度 public int Length =&gt; arr.Length; // 定义一个索引器，允许使用[]对数据进行索引 public T this[int i] &#123; get =&gt; arr[i]; set =&gt; arr[i] = value; &#125; /// &lt;summary&gt; /// 输出所有方法的name属性的值 /// &lt;/summary&gt; public void SayAllName() &#123; for (int i = 0; i &lt; arr.Length; i++) &#123; Console.WriteLine(arr[i].name); &#125; &#125;&#125; 上面这段新的代码，除了新增了一个 SayAllName 的方法之外，还有一个细节，在第一行，多了个 where T : Car，这个是为了约束这个索引器的泛型只能是继承于 Car 的类。这样，就相当于，告诉当前索引器，索引器索引的实例继承于 Car 类，所以可以在使用 Car 所允许继承的方法和属性。 索引器的使用12345678910111213141516171819public static void Main(string[] args)&#123; SimpleCollection&lt;Car&gt; simple = new SimpleCollection&lt;Car&gt;(); simple[0] = new Car(\"Car\"); simple[1] = new Car(\"Car1\"); simple[2] = new Car(\"Car2\"); simple[3] = new Car(\"Car3\"); simple[4] = new Car(\"Car4\"); simple.SayAllName();&#125;/*输出以下内容：CarCar1Car2Car3Car4*/ 由此可见，依旧可以完成我们预期的任务。但这样，可以让主函数的逻辑更加清晰明了，也方便了继承于 Car 或 Car类 的所有实例，可以使用他们共用的一种方法 SayAllName。这能大大加快了我们的编码效率。 所以，建议在日常的开发中，对需要一起操作的多个同父的类，多使用索引器，加快自己的开发效率。","categories":[{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/categories/C/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/tags/C/"}]},{"title":"JavaScript设计模式——Observe模式（观察者模式）","slug":"JavaScript设计模式——Observe模式（观察者模式）","date":"2020-07-17T12:15:21.000Z","updated":"2020-09-05T11:25:14.055Z","comments":true,"path":"JavaScript设计模式——Observe模式（观察者模式）/","link":"","permalink":"https://www.vicohu.com/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Observe%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89/","excerpt":"","text":"通常一个优秀的项目，会使用到很多的设计模式，这些设计模式在我们的解决方案中，会起到十分重要的作用，它的存在，能使项目的结构更加简洁、清晰、易于理解。所以了解常用的设计模式，会让我们在日常开发更加得心应手，也会让团队沟通变得更加顺畅。在《设计模式：可复用面向对象软件基础》一书中强调：当我们评估一个面向对象系统的质量时，所使用的方法之一就是判断系统的设计者是否强调了对象之间的公共系统关系。 简介那么在当前这个博文中，我介绍的就是 JavaScript 语言的 Observer设计模式。初次接触 Observer设计模式，是在 Vue 的双向数据绑定中。其原理就是使用了 Observer-观察者 对数据进行劫持，然后让数据的读写全部处于监管之中。然后再使用发布-订阅模式的Publish-发布者通知到Subscribe-订阅者，对数据进行进行相应操作，比如双向数据绑定中的视图更新。 所以，Vue的一个数据的写入，要经过这样一个流程。 流程图 所以，实际上，Vue 数据的双向绑定，使用到了2个设计模式：Obsever模式和Publish–Subscribe模式。(有一些人认为，观察者模式和订阅观察模式是一个模式，其实不然，他们还是有一些区别的) Observer模式（观察者模式） 就像发明一个新的东西一样，新的发明，必定会有其在现实世界的启发。就好比雷达的发明，源自于蝙蝠的超声波回声定位。火箭的发明，源自于水母、墨鱼的反冲运动。 无独有偶，观察者模式也一样。在现实社会中，经常会出现观察者这个身份。比如书店，他们就是观察者。既然，有了观察者，那一定会有被观察者，他们就像是出版社。书店“监视”各个出版社的新书，若出版社出现了新书（观察者在监视的行为），则书店获得了出版社的信息（被观察者的对象信息）和出版社的发布新书（被观察者的变化），然后书店将其发布的新书拿到，并告诉关注该类书的读者（观察者做出相应操作） Observer模式的大致流程如上。话不多说，我们着手开始用 JavaScript 实现Observer模式。 设计模式中的对象Observer 观察者 Observer是一个监视被观察者的对象，它需要提供一个接口，对数据发生改变时，做出的行为进行定义。 Subject 被观察者 在出现观察者关心的事件时，要同时通知多个观察者。 抽象模型的代码实现Observer 观察者123456var Observer = function () &#123;&#125;;// 观察者包含一个notify(通知)的回调方法Observer.prototype.notify = function (info) &#123; // 在该方法内做出操作 console.log(`观察者发现 $&#123;info&#125; 出现更改`);&#125;; Subject 被观察者123456789101112131415161718192021222324252627282930313233343536var Subject = function (info) &#123; // 注册自己（被观察者）的信息 this.info = info; // 已经注册的观察者的列表 this.observerList = [];&#125;;Subject.prototype = &#123; // 注册一个监视当前对象的观察者到观察者列表 register: function (observer) &#123; this.observerList.push(observer); &#125;, // 不在关注当前对象的观察者，注销观察者对象 remove: function (observer) &#123; // 获得当前观察者列表的长度 var listLength = this.observerList.length; for (var i = 0; i &lt; listLength; i++) &#123; if ((observer = this.observerList[i])) &#123; // 从观测者列表删除该观察者 this.observerList.splice(i, 1); return true; &#125; &#125; return false; &#125;, // 通知所有注册的观察者对象 update: function () &#123; var observer; // 获得当前观察者列表的长度 var listLength = this.observerList.length; for (var i = 0; i &lt; listLength; i++) &#123; observer = this.observerList[i]; // 调用Observer对象的notify回调方法 observer.notify(this.info); &#125; &#125;,&#125;; 小结 以上便是Observer模式的代码实现雏形，主要的流程和逻辑已经包括在其中了。但是在具体实现的时候，可以做出部分的调整。 比如： 1observer.notify(this.info); 这一句代码可以不一定要传输对象自身的所有信息，放在出版社那，可能只需要传入一个新发布的书名。 那么接下来，我们按照之前的出版社-书店-读者的例子，进行一个具体实例的代码实现。 具体实例的代码实现Observer 观察者(书店) 定义123456var BookStore = function () &#123;&#125;;// 书店包含一个notify(通知)的回调方法BookStore.prototype.notify = function (CompanyName,BookName) &#123; // 在该方法内做出操作 console.log(`读者快来，我这出了新书：$&#123;CompanyName&#125; 发版的 $&#123;BookName&#125;`);&#125;; Subject 被观察者(出版社) 定义12345678910111213141516171819202122232425262728293031323334353637383940var Company = function (CompanyName) &#123; // 出版社名称 this.Name = CompanyName; // 新的书名 this.NewBookName = \"\"; // 已经注册的书店的列表 this.bookStoreList = [];&#125;;Company.prototype = &#123; // 注册一个监视当前对象的书店到书店列表 register: function (bookStore) &#123; this.bookStoreList.push(bookStore); &#125;, // 不在关注当前对象的书店，注销书店对象 remove: function (bookStore) &#123; // 获得当前书店列表的长度 var listLength = this.bookStoreList.length; for (var i = 0; i &lt; listLength; i++) &#123; if ((bookStore == this.observerList[i])) &#123; // 从书店列表删除该观察者 this.bookStoreList.splice(i, 1); return true; &#125; &#125; return false; &#125;, // 通知所有注册的书店对象 publish: function (BookName) &#123; // 记录新发布书的名字 this.NewBookName = BookName; var bookStore; // 获得当前书店列表的长度 var listLength = this.bookStoreList.length; for (var i = 0; i &lt; listLength; i++) &#123; bookStore = this.bookStoreList[i]; // 调用BookStore对象的notify回调方法 bookStore.notify(this.Name,this.NewBookName); &#125; &#125;,&#125;; 具体使用12345678910111213141516171819202122232425262728293031// 初始化一个出版社——VicoHu出版社var company = new Company(\"VicoHu出版社\");// 初始化三家商店var bookStore1 = new BookStore(\"小胡书店\");var bookStore2 = new BookStore(\"二刘书店\");var bookStore3 = new BookStore(\"大黄书店\");// 重写bookStore3的notify方法实现发布新书时的不同操作bookStore3.notify = function (CompanyName, BookName) &#123; // 在该方法内做出操作 console.log( `$&#123;this.Name&#125;促销，新书上架：$&#123;CompanyName&#125; 发版的 $&#123;BookName&#125;，比其他的店都要便宜很多。` );&#125;;// 将三家商店注册到出版社的商店列表里company.register(bookStore1);company.register(bookStore2);company.register(bookStore3);// 发布新书company.publish(\"《挪威的森林》\");// 控制台输出如下内容/** * 小胡书店有促销活动!!!!! 读者快来，我这出了新书：VicoHu出版社 发版的 《挪威的森林》 * 二刘书店有促销活动!!!!! 读者快来，我这出了新书：VicoHu出版社 发版的 《挪威的森林》 * 大黄书店促销，新书上架：VicoHu出版社 发版的 《挪威的森林》，比其他的店都要便宜很多。 */ 小结在上面的具体实例的代码实现中，我们完成了书店的创建，和出版社的创建，并且将多个商店注册到出版社，并在出版社发布新书的时候，通知给所有的商店，让商店发出广告和通知给我们（读者）。其实，从本质上而言，商店（观察者）是被动的，它需要依赖于出版社（被观察者）调用notify方法，来完成商店的广告发布。但是，商店的广告的发布，可以通过重写 notify 方法来进行自定义的操作。 总结Observer 设计模式的优点和缺点都比较明显。 Observer模式 优点 解耦。这是现在大多数的设计模式都在做的一件事情，例如：MVC、MVVM等。其好处就在于，不需要在设计观察者的时候，关注被观察者的设计。这样可以只需要关注一个notify方法的参数。这样的好处很明显，可以把更多的注意力放在设计某个对象的上面。 广播通讯。如我们后面发布的 《挪威的森林》一书，只需要调用一出版社的publish方法，就可以对所有已经在出版社注册的商店进行通知。 Observer模式 缺点 观察者过于被动。观察者在这个设计中，其实更像是个被通知的身份，它没有主动了解被观察者的能力。只能根据观察者给的信息，做出反应和操作。 抗风险性不高。假如某个注册的商店的方法出现问题，或者一直未执行完，会影响到后面的商店的通知。从而影响整体广播的执行。 最后的总结 这世界上没有绝对通用的设计模式，都是根据任务的需求，选择合适的设计模式。但是，倘若你连某个合适的设计模式都不知道，就会错过一些事半功倍的机会。所以，只有不断的去学习，不断走出舒适圈，才能让自己走的更远，并成为一个编码更加高效、稳定的开发者。加油吧！各位！","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.vicohu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript","slug":"设计模式/JavaScript","permalink":"https://www.vicohu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/JavaScript/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.vicohu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.vicohu.com/tags/JavaScript/"}]},{"title":"Vue中v-for配合key使用的重要性","slug":"Vue中v-for配合key使用的重要性","date":"2020-07-12T15:15:21.000Z","updated":"2020-09-05T11:25:14.056Z","comments":true,"path":"Vue中v-for配合key使用的重要性/","link":"","permalink":"https://www.vicohu.com/Vue%E4%B8%ADv-for%E9%85%8D%E5%90%88key%E4%BD%BF%E7%94%A8%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/","excerpt":"","text":"在 Vue 官网的风格指南中，有很多对于Vue编码的风格的要求和建议。在这里，主要解释在编码指南中，为优先级A：必要的 的编码规范的","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.vicohu.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.vicohu.com/tags/Vue/"}]},{"title":"Vue中v-if和v-show的区别和使用场景","slug":"Vue中v-if和v-show的区别和使用场景","date":"2020-07-05T10:19:21.000Z","updated":"2020-09-05T11:25:14.056Z","comments":true,"path":"Vue中v-if和v-show的区别和使用场景/","link":"","permalink":"https://www.vicohu.com/Vue%E4%B8%ADv-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"我们在学习Vue的时候，肯定产生过对 v-if 和 v-show 的区别存在疑惑。在不深入到渲染逻辑的情况下，大到时候，给开发者的直观感受都是一样的：显示和不显示。但在实现的本质上，是有差别的。 其实在Vue的官方文档中，也有做出一些相应的解释。 概念和区别官方文档概念v-if v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。1 v-show v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。 区别根据以上的官方文档，其实就已经表明出了其背后的渲染逻辑。 v-if 是根据表达式返回的值，来判断是否渲染，更准确的说是，假如表达式返回值为 false，则直接跳过该元素及其子元素的渲染，根本不消耗资源去生成相应的 Virtual DOM。换句话说，v-if 的表达式返回值，会直接触发到 当前组件 生命周期，并且事件监听器和子组件会被适当地被销毁和重建。所以，可以理解为 v-if 是惰性的，他不会在页面初始化时，被无条件渲染，而是按需响应式地渲染。 而 v-show ，这是无论表达式返回值是否是 true 都会在 create 生命周期，无条件消耗资源生成对应的 Virtual DOM，并挂载到HTML页面中，只是再根据表达式返回值，切换 display 这个 CSS 属性。 使用场景从页面显示上看，二者并没有太多的区别，基本上就是显示和不显示的用户体验差别。在需要频繁切换显示状态的组件或者相对渲染强度大但是过分依赖生命周期或的组件，更加适合用 v-show 作为切换的指令。因为，v-if 会带来实时渲染所带来的不必要的资源消耗，和操作延迟，这给用户的体验并不是很好，相对下，v-show基于CSS的显示与隐藏，更加快捷，响应速度更快，并且资源消耗也会更小。但 v-show 的弱点也很明显，因为页面是在页面初始化的时候，就得完成全部的渲染，这使得页面的加载会更消耗资源，也意味着页面加载时长会相应增长。假如组件对资源的消耗，已经影响到了用户的体验，可能采取 v-if 将组件分成小块，按需加载或许会更加有用户体验。 总而言之，v-if 是在表达式返回值切换时，才渲染和摧毁组件及其子组件，他会触发组件的生命周期。而 v-show 是在页面初始化时就进行了完整的渲染，这会在某些情况下，明显增加页面的加载时间。具体的使用，还得根据需求、页面的加载时长以及组件的渲染强度，进行合适的选择。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://www.vicohu.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.vicohu.com/tags/Vue/"}]},{"title":".Net Core3.1 WebAPI CORS跨域配置——踩坑","slug":"net core3.1 CORS跨域配置——踩坑","date":"2020-06-23T09:35:42.000Z","updated":"2020-09-05T11:25:14.057Z","comments":true,"path":"net core3.1 CORS跨域配置——踩坑/","link":"","permalink":"https://www.vicohu.com/net%20core3.1%20CORS%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E8%B8%A9%E5%9D%91/","excerpt":"","text":"之前在用Vue开发的过程中，使用到了.Net Core 3.1 的 WebAPI，然后必然要解决一个 CORS 跨域的问题。根据百度，学习到了配置配置跨域的方法。一运行项目访问接口，就直接在Startup类中直接报错 报错异常如下图1234System.InvalidOperationException HResult&#x3D;0x80131509 Message&#x3D;The CORS protocol does not allow specifying a wildcard (any) origin and credentials at the same time. Configure the CORS policy by listing individual origins if credentials needs to be supported. Source&#x3D;Microsoft.AspNetCore.Cors 其实解决方案也很简单： 在Startup类的ConfigureServices方法中添加如下代码：1234567891011&#x2F;&#x2F;添加cors 服务 配置跨域处理 services.AddCors(options &#x3D;&gt;&#123; options.AddPolicy(&quot;any&quot;, builder &#x3D;&gt; &#123; builder.WithMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;HEAD&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;) &#x2F;&#x2F;.AllowCredentials()&#x2F;&#x2F;指定处理cookie .AllowAnyOrigin(); &#x2F;&#x2F;允许任何来源的主机访问 &#125;);&#125;); 在Startup类的Configure方法中添加如下代码：12app.UseCors(&quot;any&quot;);&#x2F;&#x2F; 注意，这一行代码一定要写在 app.UseAuthorization(); 的下面，否则会报错的。 以上就是 .Net Core3.1 CORS跨域配置的解决方案。","categories":[{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/categories/C/"},{"name":".Net","slug":"C/Net","permalink":"https://www.vicohu.com/categories/C/Net/"},{"name":".Net Core3.1","slug":"C/Net/Net-Core3-1","permalink":"https://www.vicohu.com/categories/C/Net/Net-Core3-1/"}],"tags":[{"name":"WebAPI","slug":"WebAPI","permalink":"https://www.vicohu.com/tags/WebAPI/"},{"name":".Net Core3.1","slug":"Net-Core3-1","permalink":"https://www.vicohu.com/tags/Net-Core3-1/"}]},{"title":".gitignore 无效的解决方案","slug":"gitignore 无效的解决方案","date":"2020-06-21T07:30:26.000Z","updated":"2020-09-05T11:25:14.056Z","comments":true,"path":"gitignore 无效的解决方案/","link":"","permalink":"https://www.vicohu.com/gitignore%20%E6%97%A0%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"我们在使用git的时候，经常会使用.gitignore文件，定义规则，对项目文件进行上传筛选但在某些时候，我们可能会出现在项目已经创建，或者项目的中途，创建该文件，而导致的改文件无法生效的情况。 这是因为 .gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。我们可以尝试用清除本地缓存的方法，解决该问题。 1234git rm -r --cached .git add .git commit -m &quot;update .gitignore&quot;git push -u origin master","categories":[{"name":"Git","slug":"Git","permalink":"https://www.vicohu.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.vicohu.com/tags/Git/"}]},{"title":"C# .Net CodeFist编码基础流程","slug":"CSharp .Net CodeFist编码基础流程","date":"2020-06-17T10:20:21.000Z","updated":"2020-09-05T11:25:14.055Z","comments":true,"path":"CSharp .Net CodeFist编码基础流程/","link":"","permalink":"https://www.vicohu.com/CSharp%20.Net%20CodeFist%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/","excerpt":"","text":"Code First 基础流程 1. 定义好实体类（对应数据库的表及其字段） 2. 定义好上下文操作类（以context结尾） 12345678910&#x2F;&#x2F;在该项目上右键找到“管理 NuGet程序包” 搜索EntityFrameWork并下载好public nCovContext() : base(&quot;name&#x3D;aa&quot;) &#x2F;&#x2F; 声明连接字符串&#123;&#125;&#x2F;&#x2F; 注册实体类 public DbSet&lt;tbStudent&gt; tbStudent &#123; get; set; &#125;public DbSet&lt;tbTeacher&gt; tbTeacher &#123; get; set; &#125;public DbSet&lt;tbDetail&gt; tbDetail &#123; get; set; &#125; 3. 在App.config里加上数据库连接字符串 123&lt;connectionStrings&gt; &lt;add name&#x3D;&quot;aa&quot; connectionString&#x3D;&quot;server&#x3D;.;database&#x3D;nCov3804DB;uid&#x3D;sa;pwd&#x3D;123456&quot; providerName&#x3D;&quot;System.Data.SqlClient&quot; &#x2F;&gt;&lt;&#x2F;connectionStrings&gt; 【注意: 上下文操作类的构造方法的name=”aa”要与App.config的name=aa保持一致】 Code First模式默认的约定 主键约定： 以ID或者是类型ID的字段会自动生成为主键。如果是Int类型，会默认为自增 表名约定：跟类名一样，会默认加上一个s 一对多的约定：导航属性。 字符串约定：string =&gt; nvarchar(Max),默认允许为空","categories":[{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/categories/C/"},{"name":".Net","slug":"C/Net","permalink":"https://www.vicohu.com/categories/C/Net/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/tags/C/"},{"name":".Net","slug":"Net","permalink":"https://www.vicohu.com/tags/Net/"}]},{"title":"LeetCode——打家劫舍问题——动态规划","slug":"LeetCode——打家劫舍问题——动态规划","date":"2020-05-27T13:27:27.000Z","updated":"2020-09-05T11:25:14.056Z","comments":true,"path":"LeetCode——打家劫舍问题——动态规划/","link":"","permalink":"https://www.vicohu.com/LeetCode%E2%80%94%E2%80%94%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"打家劫舍问题你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。 偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。 示例 2: 1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。 偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。 对于求最优解得题目，我编码效率最快的，自然是递归，但是，递归在数组的长度越来越长是，所需的世界也会飞速增长。因为递归进行了很多重复的运算。对于本题而言，或许动态规划更加适合当前题目的情景。根据题目规则我们可以得到几个信息。 Opt[i] = （ Opt[i - 2] + Nums[i] ） 或者 （Opt[i - 1]） i为第i个元素，opt[i]为第i个及其之前的元素的最优解（不考虑之后的元素，只考虑当前元素和之前的元素），Nums为传入的数组 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int rob(int[] nums) &#123; int y = 0, n = 0; // 初始化2个变量，代表着选取该节点和不选取该节点。y: yes, n: no int[] opt = new int[nums.length]; // 初始化一个数组，用于存储每个节点的当前元素及其之前元素的最优解（不管之后的元素 是否选择） if (nums.length == 0) &#123; // 如果传入的数组为空，返回值为0 return 0; &#125; if (nums.length == 1) &#123; // 如果传入的值为1，返回值为当前数组的唯一元素 return nums[0]; &#125; // 如果，满足传入数组的长度大于等于2 opt[0] = nums[0]; opt[1] = Math.max(nums[0],nums[1]); // 第一个元素及之前元素的最优解为第一个元素本身 // 第二个元素及之前元素的最优解为第一个元素或者第二个元素（取大值） for(int i = 2;i &lt;= nums.length - 1; i++ ) &#123; // 循环计算，2和2之后每一个元素及之前元素的最优解 // 每个节点都会遇到2个可能，需要当前元素和不需要当前元素 y = nums[i] + opt[i - 2]; n = opt[i - 1]; opt[i] = Math.max(y,n); // 取最优解 &#125; Arrays.sort(opt); // 对最优解进行排序，取最大值即为当前题目的最优解 return opt[nums.length - 1]; // 返回排序后最后一个元素（最大的元素） &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"Java","slug":"算法/LeetCode/Java","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.vicohu.com/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.vicohu.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"https://www.vicohu.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.vicohu.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"LeetCode——会议室 II——动态规划","slug":"LeetCode——会议室 II——动态规划","date":"2020-05-26T07:51:22.000Z","updated":"2020-09-05T11:25:14.055Z","comments":true,"path":"LeetCode——会议室 II——动态规划/","link":"","permalink":"https://www.vicohu.com/LeetCode%E2%80%94%E2%80%94%E4%BC%9A%E8%AE%AE%E5%AE%A4%20II%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"会议室 II给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si &lt; ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。 示例 1: 12输入: [[0, 30],[5, 10],[15, 20]]输出: 2 示例 2: 12输入: [[7,10],[2,4]]输出: 1 这个题目有点类似于上下车问题。本题是规划的对于时间冲突的解决方案。根据题目，我们发现，并不需要在意该会议持续时间。因为会议时间已经固定了，所以我们只需要关注会议室及其会议结束时间即可。因为只有会议时间结束，才能进行下一个会议。否则，这需要开一个新的会议室，去进行会议。为了最优开会成本和时间效率，下一个会议进入的房间，根据会议室结束时间和该会议开始时间的差决定，时间差越小，开会越能“无缝连接”，于是效率越高。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public int minMeetingRooms(int[][] intervals) &#123; if(intervals == null || intervals.length ==0) return 0; // 根据会议开始时间，数组的重新排序（开始时间的从小到大） Arrays.sort(intervals,new Comparator&lt;&gt;()&#123; @Override public int compare(int[] o1, int[] o2) &#123; return o1[0]-o2[0]; &#125; &#125;); // 定义一个HashMap记录会议室及其结束时间 Map&lt;Integer,Integer&gt; RoomTime = new HashMap&lt;&gt;(); // 第一个开始会议的已经毋庸置疑，就是开会时间最早的那个会议，也就是排序后的第一个会议 RoomTime.put(1,intervals[0][1]); // 定义一个表示符号，用于后面的forEach跳过第一个会议，因为第一个会议已经安排好了 boolean isFirst = false; for(int[] item :intervals)&#123; if(!isFirst) &#123; // 跳过第一个会议，因为已经安排了 isFirst = !isFirst; continue; &#125; // 时间差 int fix = 0; // 该会议，目前临时安排的房间 int tempRoom = 0; // 循环所有会议室 for(Map.Entry&lt;Integer,Integer&gt; entry: RoomTime.entrySet())&#123; // 如果时间上满足要求 if(entry.getValue() &lt;= item[0]) &#123; // 取最优的会议室给当前会议 if(fix == 0 || item[0] - entry.getValue() &lt;= fix) &#123; fix = item[0] - entry.getValue(); tempRoom = entry.getKey(); &#125; &#125; &#125; // 如果临时间号不为0，则有房间满足要求。否则，说明没有房间满足要求，需要开一个新的会议室，安排该会议 if(tempRoom != 0) RoomTime.put(tempRoom, item[1]); else RoomTime.put(RoomTime.size() + 1,item[1]); &#125; // 最后返回房间的数量，即是本题的答案 return RoomTime.size(); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"Java","slug":"算法/LeetCode/Java","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.vicohu.com/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.vicohu.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"https://www.vicohu.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.vicohu.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"教你如何快速刷网课","slug":"教你如何快速刷网课","date":"2020-05-22T10:20:21.000Z","updated":"2020-09-09T11:59:31.430Z","comments":true,"path":"教你如何快速刷网课/","link":"","permalink":"https://www.vicohu.com/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%B7%E7%BD%91%E8%AF%BE/","excerpt":"","text":"这段时间，疫情之下，直播课、网课，得到了空前的发展和壮大。并且应运出很多奇葩的课程，“大学生体育”，里面教你怎么打篮球，怎么打羽毛球，然而，却根本没人可以在家中完成以上联系。“体育”竟然变成了一种偏理论的课程，并且长达十几个小时。实在诙谐。 于是，在朋友的介绍下，我得知了一个惊天地泣鬼神的快速刷完网课的方式——“代刷网课“. 代刷网课“代刷网课”这个产业，在疫情期间，得到了越多人的认可。因为他可以为学生节省很多的时间，去完成一些他们愿意做的事情，比如我放弃了奇葩的”大学生体育”，学习Vue3和Nuxt.js，这十几个小时，可以完成太多的事情。而请”代刷“的成本，却不过2-3元不等，何乐而不为呢？ 我相信大多数人都明白，有些课程的意义是真的对于不感兴趣的人而言，是没有价值的。只会增加大学的心理负担。而刷网课，虽然表面不光鲜亮丽，但却是一种很好的方式，去节省我们大学期间宝贵的时间。我们可以拿着十几到几十小时不等的时间，去学习自己喜欢的事情，或者和室友朋友花这时间去聊天、娱乐毕竟大学不仅是学习专业知识，更多的是锻炼人际交往的能力。这是进入社会必会的技能。 怎样代刷网课在我的朋友的介绍下，我得知一个专业刷网课的平台，这个刷网课平台是他和几个计算机软件技术专业的朋友，共同搭建和完成的，并且在运营发现月收益可以大于月成本后，他们便一直在维护这个网站的运行，并维护着刷网课脚本的功能。运行至今也有3年的时间了。 刷网课平台地址：点击进入，VicoHu刷网课平台 点击上面链接，进入刷网课平台 你会看到到如下页面： VicoHu网课刷网课平台 然后，我们点击蓝色按钮的提交课程 VicoHu网课刷网课平台 至于选择点击哪一个，则需要依照你需要刷的网课的平台来，例如：超星学习通、智慧树/知到，这些均在爆单网课平台中。 我们拿超星学习通为例，进入后选择学习通/超星，并填写相关信息，和下单数量（一科一份，多科多份） VicoHu网课刷网课平台 然后点击查询课程，会弹出一个提示框，我们点击确定按钮 VicoHu网课刷网课平台 点击上图确定后，耐心等待片刻，会再次弹出一个框，勾选要刷的网课，再“确认选择”，然后点击“立刻购买”即可。 VicoHu网课刷网课平台 然后，便根据下方的提示，不要在手机或电脑上频繁登录账号，一般网课根据时长1-3天不等，便可以刷完。 在选择商品时，可以看到有“代刷”，“高质量代刷”和”秒刷 超级速“， 3种类别，”代刷“就是最普通的刷网课，速度中等一般2-3天刷完，相对比较稳定。“高质量代刷”。是销量最好的，也是老用户最喜欢的刷课选项，速度1-2天左右刷完，速度相对较快，极其稳定，上线至今0失误。”秒刷 超级速“这款是针对网课快要截止的用户，可以在几小时到半天时间内刷完网课，速度极快。 为什么要代刷网课，为什么出现代刷网课（我的一点思考和见解）本质上，学生想刷网课嘛？其实是不想的，他们心里会背负一种内疚感。如果你里面放的是他们想要的东西，感兴趣的东西，或者是真的对未来有可见价值的东西，我相信绝大部分人都不会拒绝。代刷网课只是一种节省掉低效时间、低价值时间的工具。工具本身又怎么会有错呢。 代刷网课，在我朋友那是副业，在大学生那是工具，而对于我而言是一种新的思考。 思考为什么网课里会出现这样没有什么价值的课程，却依旧有着和其他重要的课程一样的学分？思考为什么我们喊着反对应试教育，要因材施教的情况下，却依旧在网课这没有改善。 我们中国的大学教育者是不是该反思，而不是抱着一种，只要学生看完了，自己任务就完成的心态，去教育学生。而应该更多的去思考，怎么让把一个可能学生不兴趣但一定有价值的课程，变得有趣，变得更有价值，变得让学生更容易接受。我相信，教育的方向绝对不是说让大学生依靠自己的“自觉”去学习。这不过是大学教师给自己台阶，给自己不认真备课的借口。 我承认教育者，有他的辛苦之处，可是哪个行业不辛苦呢？我们软件工程师经常的996，却很多时候拿着和大学的老师有着差不多的工资。但我们会说不加班了吗？不会，因为我们知道，我们不996就意味着，我们丢失了工作，意味着我们不知道下一顿饭在哪。 我们都应该，为自己的职位的职责付出应该的努力。同样，大学生也该为自己省略那些观看对于自己低价值课程的时间。去做自己喜欢的事情，去做有价值的事情，去做那个追逐自己内心的自己。","categories":[{"name":"小技巧","slug":"小技巧","permalink":"https://www.vicohu.com/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"刷网课","slug":"刷网课","permalink":"https://www.vicohu.com/tags/%E5%88%B7%E7%BD%91%E8%AF%BE/"},{"name":"大学生刷网课","slug":"大学生刷网课","permalink":"https://www.vicohu.com/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%88%B7%E7%BD%91%E8%AF%BE/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://www.vicohu.com/categories/Java/"},{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/categories/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.vicohu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript","slug":"设计模式/JavaScript","permalink":"https://www.vicohu.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://www.vicohu.com/categories/Vue/"},{"name":".Net","slug":"C/Net","permalink":"https://www.vicohu.com/categories/C/Net/"},{"name":".Net Core3.1","slug":"C/Net/Net-Core3-1","permalink":"https://www.vicohu.com/categories/C/Net/Net-Core3-1/"},{"name":"Git","slug":"Git","permalink":"https://www.vicohu.com/categories/Git/"},{"name":"算法","slug":"算法","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"算法/LeetCode","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"Java","slug":"算法/LeetCode/Java","permalink":"https://www.vicohu.com/categories/%E7%AE%97%E6%B3%95/LeetCode/Java/"},{"name":"小技巧","slug":"小技巧","permalink":"https://www.vicohu.com/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.vicohu.com/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://www.vicohu.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"C#","slug":"C","permalink":"https://www.vicohu.com/tags/C/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.vicohu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.vicohu.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://www.vicohu.com/tags/Vue/"},{"name":"WebAPI","slug":"WebAPI","permalink":"https://www.vicohu.com/tags/WebAPI/"},{"name":".Net Core3.1","slug":"Net-Core3-1","permalink":"https://www.vicohu.com/tags/Net-Core3-1/"},{"name":"Git","slug":"Git","permalink":"https://www.vicohu.com/tags/Git/"},{"name":".Net","slug":"Net","permalink":"https://www.vicohu.com/tags/Net/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://www.vicohu.com/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"https://www.vicohu.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"https://www.vicohu.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"刷网课","slug":"刷网课","permalink":"https://www.vicohu.com/tags/%E5%88%B7%E7%BD%91%E8%AF%BE/"},{"name":"大学生刷网课","slug":"大学生刷网课","permalink":"https://www.vicohu.com/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%88%B7%E7%BD%91%E8%AF%BE/"}]}